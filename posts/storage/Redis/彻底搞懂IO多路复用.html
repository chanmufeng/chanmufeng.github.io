<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.49" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://www.chanmufeng.com/posts/storage/Redis/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html"><meta property="og:site_name" content="蝉沐风"><meta property="og:title" content="彻底搞懂IO多路复用"><meta property="og:description" content="本篇文章为BIO与阻塞IO的续篇，详细介绍了select、poll以及epoll等多路复用组件的使用方法以及底层原理。尤其详细分析了epoll的源码，做到一篇文章完全搞懂I/O多路复用模型"><meta property="og:type" content="article"><meta property="og:updated_time" content="2023-01-31T05:32:08.000Z"><meta property="og:locale" content="zh-CN"><meta property="article:tag" content="多路复用"><meta property="article:tag" content="select"><meta property="article:tag" content="poll"><meta property="article:tag" content="epoll"><meta property="article:published_time" content="2023-01-31T00:00:00.000Z"><meta property="article:modified_time" content="2023-01-31T05:32:08.000Z"><script>
                var _hmt = _hmt || [];
                (function() {
                  var hm = document.createElement("script");
                  hm.src = "https://hm.baidu.com/hm.js?dfa689801ccd10bd283b50ea146430f3";
                  var s = document.getElementsByTagName("script")[0]; 
                  s.parentNode.insertBefore(hm, s);
                })();
            </script><title>彻底搞懂IO多路复用 | 蝉沐风</title><meta name="description" content="本篇文章为BIO与阻塞IO的续篇，详细介绍了select、poll以及epoll等多路复用组件的使用方法以及底层原理。尤其详细分析了epoll的源码，做到一篇文章完全搞懂I/O多路复用模型">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d2025;
      }

      html,
      body {
        background-color: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="stylesheet" href="/assets/style.ef97199c.css">
    <link rel="modulepreload" href="/assets/app.33c79bea.js"><link rel="modulepreload" href="/assets/彻底搞懂IO多路复用.html.4a6caed1.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper.21dcd24c.js"><link rel="modulepreload" href="/assets/彻底搞懂IO多路复用.html.7ec25f7a.js"><link rel="prefetch" href="/assets/index.html.f40aab20.js"><link rel="prefetch" href="/assets/home.html.4311fb4f.js"><link rel="prefetch" href="/assets/update.html.8aa9089e.js"><link rel="prefetch" href="/assets/index.html.bc679553.js"><link rel="prefetch" href="/assets/index.html.42b16337.js"><link rel="prefetch" href="/assets/disable.html.a298796c.js"><link rel="prefetch" href="/assets/encrypt.html.04234872.js"><link rel="prefetch" href="/assets/markdown.html.c40cf8e1.js"><link rel="prefetch" href="/assets/JVM到底该学习些什么.html.37a1cd31.js"><link rel="prefetch" href="/assets/index.html.bdb8aaf2.js"><link rel="prefetch" href="/assets/我是一个垃圾.html.396cd500.js"><link rel="prefetch" href="/assets/CPU流水线与指令重排序.html.da7853a1.js"><link rel="prefetch" href="/assets/index.html.9cfc822d.js"><link rel="prefetch" href="/assets/用「闪电侠」解释一下进程和线程.html.9c93b056.js"><link rel="prefetch" href="/assets/缓存一致性与内存屏障.html.51552874.js"><link rel="prefetch" href="/assets/index.html.67e2e3d9.js"><link rel="prefetch" href="/assets/network-programming.html.287d3b4f.js"><link rel="prefetch" href="/assets/index.html.0a6236b7.js"><link rel="prefetch" href="/assets/什么是文件描述符.html.804cd066.js"><link rel="prefetch" href="/assets/index.html.1f5ae493.js"><link rel="prefetch" href="/assets/动态代理模式.html.90a17679.js"><link rel="prefetch" href="/assets/单例模式.html.c3742e12.js"><link rel="prefetch" href="/assets/工厂模式.html.f8c7f9d6.js"><link rel="prefetch" href="/assets/静态代理模式.html.7bbcf6f5.js"><link rel="prefetch" href="/assets/依赖倒置原则.html.56bde280.js"><link rel="prefetch" href="/assets/开闭原则.html.d45ce1b8.js"><link rel="prefetch" href="/assets/Google搜索为什么不能无限分页？.html.5b88d232.js"><link rel="prefetch" href="/assets/index.html.abd3d401.js"><link rel="prefetch" href="/assets/m1芯片电脑安装cerebro.html.0120f768.js"><link rel="prefetch" href="/assets/MySQL与Redis的数据一致性.html.5ba6736f.js"><link rel="prefetch" href="/assets/MySQL优化的5个维度.html.4362df81.js"><link rel="prefetch" href="/assets/MySQL索引的正确使用姿势.html.d51dd9cb.js"><link rel="prefetch" href="/assets/MySQL锁开篇.html.36ef8a4c.js"><link rel="prefetch" href="/assets/index.html.d1d4b825.js"><link rel="prefetch" href="/assets/一条SELECT语句是如何执行的.html.2ace0b89.js"><link rel="prefetch" href="/assets/一条Update语句是如何执行的.html.8736dea8.js"><link rel="prefetch" href="/assets/为什么MySQL的主键查询这么快.html.69305ec3.js"><link rel="prefetch" href="/assets/为什么不建议你使用SELECT_.html.ee5e1bb5.js"><link rel="prefetch" href="/assets/事务的隔离性与MVCC.html.a4ad4ac5.js"><link rel="prefetch" href="/assets/从根儿上理解索引.html.c7e89f33.js"><link rel="prefetch" href="/assets/BIO与非阻塞IO.html.56cc747b.js"><link rel="prefetch" href="/assets/index.html.d1211743.js"><link rel="prefetch" href="/assets/Redis持久化——AOF.html.3ef66ec5.js"><link rel="prefetch" href="/assets/Redis持久化——RDB.html.956f2216.js"><link rel="prefetch" href="/assets/同步异步与阻塞非阻塞.html.cef3437e.js"><link rel="prefetch" href="/assets/鸡肋的Redis事务.html.bf1172f2.js"><link rel="prefetch" href="/assets/index.html.ccdcd4de.js"><link rel="prefetch" href="/assets/从0到1编写一款插件.html.5f51ccf3.js"><link rel="prefetch" href="/assets/index.html.14c31047.js"><link rel="prefetch" href="/assets/后端开发者的M1版Mac开发环境搭建.html.aead2f64.js"><link rel="prefetch" href="/assets/index.html.530ae07a.js"><link rel="prefetch" href="/assets/如何同步配置.html.21989554.js"><link rel="prefetch" href="/assets/404.html.4285bac5.js"><link rel="prefetch" href="/assets/index.html.6717b2b6.js"><link rel="prefetch" href="/assets/index.html.5eae9e3f.js"><link rel="prefetch" href="/assets/index.html.85231e1c.js"><link rel="prefetch" href="/assets/index.html.07ef0efd.js"><link rel="prefetch" href="/assets/index.html.e5d6f701.js"><link rel="prefetch" href="/assets/index.html.accaa64c.js"><link rel="prefetch" href="/assets/index.html.9a9f30d6.js"><link rel="prefetch" href="/assets/index.html.68e6d714.js"><link rel="prefetch" href="/assets/index.html.b032f382.js"><link rel="prefetch" href="/assets/index.html.bc540566.js"><link rel="prefetch" href="/assets/index.html.4fa328ce.js"><link rel="prefetch" href="/assets/index.html.2c9f8626.js"><link rel="prefetch" href="/assets/index.html.6c184523.js"><link rel="prefetch" href="/assets/index.html.2309c271.js"><link rel="prefetch" href="/assets/index.html.94d1334e.js"><link rel="prefetch" href="/assets/index.html.3e9b5a53.js"><link rel="prefetch" href="/assets/index.html.da976a01.js"><link rel="prefetch" href="/assets/index.html.843e0dc5.js"><link rel="prefetch" href="/assets/index.html.e6adfc22.js"><link rel="prefetch" href="/assets/index.html.a46272a6.js"><link rel="prefetch" href="/assets/index.html.e68eec84.js"><link rel="prefetch" href="/assets/index.html.c3c92e66.js"><link rel="prefetch" href="/assets/index.html.a1ffa21c.js"><link rel="prefetch" href="/assets/index.html.5c810edd.js"><link rel="prefetch" href="/assets/index.html.7b661157.js"><link rel="prefetch" href="/assets/index.html.a61ab275.js"><link rel="prefetch" href="/assets/index.html.cd04393b.js"><link rel="prefetch" href="/assets/index.html.6ea94130.js"><link rel="prefetch" href="/assets/index.html.938c47df.js"><link rel="prefetch" href="/assets/index.html.b6e53603.js"><link rel="prefetch" href="/assets/index.html.abfe5d6e.js"><link rel="prefetch" href="/assets/index.html.799762a8.js"><link rel="prefetch" href="/assets/index.html.6a1f2c2a.js"><link rel="prefetch" href="/assets/index.html.91d708f1.js"><link rel="prefetch" href="/assets/index.html.2b208795.js"><link rel="prefetch" href="/assets/index.html.970ad9a6.js"><link rel="prefetch" href="/assets/index.html.18750c91.js"><link rel="prefetch" href="/assets/index.html.5832ab43.js"><link rel="prefetch" href="/assets/index.html.46963a2e.js"><link rel="prefetch" href="/assets/index.html.d8d0f261.js"><link rel="prefetch" href="/assets/index.html.656424fd.js"><link rel="prefetch" href="/assets/index.html.740f6c3e.js"><link rel="prefetch" href="/assets/index.html.75361b30.js"><link rel="prefetch" href="/assets/index.html.77d7aba9.js"><link rel="prefetch" href="/assets/index.html.c6475c4b.js"><link rel="prefetch" href="/assets/index.html.4f4df111.js"><link rel="prefetch" href="/assets/index.html.2ef7b821.js"><link rel="prefetch" href="/assets/index.html.0dc0a64e.js"><link rel="prefetch" href="/assets/index.html.8bde1faf.js"><link rel="prefetch" href="/assets/index.html.a8e5dab4.js"><link rel="prefetch" href="/assets/index.html.8dbe4bd2.js"><link rel="prefetch" href="/assets/index.html.72d090a7.js"><link rel="prefetch" href="/assets/index.html.f0f01938.js"><link rel="prefetch" href="/assets/index.html.899ba14c.js"><link rel="prefetch" href="/assets/index.html.1aac5a85.js"><link rel="prefetch" href="/assets/index.html.00e1e5ed.js"><link rel="prefetch" href="/assets/index.html.79aed47e.js"><link rel="prefetch" href="/assets/index.html.d40b22a3.js"><link rel="prefetch" href="/assets/index.html.8a67630a.js"><link rel="prefetch" href="/assets/index.html.2c357d93.js"><link rel="prefetch" href="/assets/index.html.1176370d.js"><link rel="prefetch" href="/assets/index.html.363a85f2.js"><link rel="prefetch" href="/assets/index.html.50661535.js"><link rel="prefetch" href="/assets/index.html.47d81d31.js"><link rel="prefetch" href="/assets/index.html.3f91cdc4.js"><link rel="prefetch" href="/assets/index.html.3bf9cde9.js"><link rel="prefetch" href="/assets/index.html.e1b6caad.js"><link rel="prefetch" href="/assets/home.html.67bff8c1.js"><link rel="prefetch" href="/assets/update.html.ddafb635.js"><link rel="prefetch" href="/assets/index.html.f9b531c0.js"><link rel="prefetch" href="/assets/index.html.be1f2e75.js"><link rel="prefetch" href="/assets/disable.html.844d2d68.js"><link rel="prefetch" href="/assets/encrypt.html.d19af41b.js"><link rel="prefetch" href="/assets/markdown.html.629ae0bc.js"><link rel="prefetch" href="/assets/JVM到底该学习些什么.html.62f130cc.js"><link rel="prefetch" href="/assets/index.html.7ba1e744.js"><link rel="prefetch" href="/assets/我是一个垃圾.html.c92f3bcb.js"><link rel="prefetch" href="/assets/CPU流水线与指令重排序.html.3e7cd42b.js"><link rel="prefetch" href="/assets/index.html.cd870374.js"><link rel="prefetch" href="/assets/用「闪电侠」解释一下进程和线程.html.9e995a1c.js"><link rel="prefetch" href="/assets/缓存一致性与内存屏障.html.2a95ca7e.js"><link rel="prefetch" href="/assets/index.html.7eb868d7.js"><link rel="prefetch" href="/assets/network-programming.html.5e8d0c35.js"><link rel="prefetch" href="/assets/index.html.3094941a.js"><link rel="prefetch" href="/assets/什么是文件描述符.html.66d41663.js"><link rel="prefetch" href="/assets/index.html.430efdf1.js"><link rel="prefetch" href="/assets/动态代理模式.html.3bd5a19f.js"><link rel="prefetch" href="/assets/单例模式.html.1ccae41a.js"><link rel="prefetch" href="/assets/工厂模式.html.17574a39.js"><link rel="prefetch" href="/assets/静态代理模式.html.eceb5cf4.js"><link rel="prefetch" href="/assets/依赖倒置原则.html.df591b57.js"><link rel="prefetch" href="/assets/开闭原则.html.fc87eac6.js"><link rel="prefetch" href="/assets/Google搜索为什么不能无限分页？.html.328d8de3.js"><link rel="prefetch" href="/assets/index.html.d427f8aa.js"><link rel="prefetch" href="/assets/m1芯片电脑安装cerebro.html.36a58db7.js"><link rel="prefetch" href="/assets/MySQL与Redis的数据一致性.html.54ed0d43.js"><link rel="prefetch" href="/assets/MySQL优化的5个维度.html.0b12b1a3.js"><link rel="prefetch" href="/assets/MySQL索引的正确使用姿势.html.23c10023.js"><link rel="prefetch" href="/assets/MySQL锁开篇.html.8abc11b1.js"><link rel="prefetch" href="/assets/index.html.e78860db.js"><link rel="prefetch" href="/assets/一条SELECT语句是如何执行的.html.34e03ece.js"><link rel="prefetch" href="/assets/一条Update语句是如何执行的.html.62145a3f.js"><link rel="prefetch" href="/assets/为什么MySQL的主键查询这么快.html.9755b124.js"><link rel="prefetch" href="/assets/为什么不建议你使用SELECT_.html.10cda53f.js"><link rel="prefetch" href="/assets/事务的隔离性与MVCC.html.dc48a5ca.js"><link rel="prefetch" href="/assets/从根儿上理解索引.html.c07ada76.js"><link rel="prefetch" href="/assets/BIO与非阻塞IO.html.6270d9ec.js"><link rel="prefetch" href="/assets/index.html.03e4d554.js"><link rel="prefetch" href="/assets/Redis持久化——AOF.html.c975ee30.js"><link rel="prefetch" href="/assets/Redis持久化——RDB.html.a563ec02.js"><link rel="prefetch" href="/assets/同步异步与阻塞非阻塞.html.3e3a8c87.js"><link rel="prefetch" href="/assets/鸡肋的Redis事务.html.3487ae58.js"><link rel="prefetch" href="/assets/index.html.102f0479.js"><link rel="prefetch" href="/assets/从0到1编写一款插件.html.b516306d.js"><link rel="prefetch" href="/assets/index.html.7987ca79.js"><link rel="prefetch" href="/assets/后端开发者的M1版Mac开发环境搭建.html.28905622.js"><link rel="prefetch" href="/assets/index.html.99351bc6.js"><link rel="prefetch" href="/assets/如何同步配置.html.12e452b7.js"><link rel="prefetch" href="/assets/404.html.7475bf3f.js"><link rel="prefetch" href="/assets/index.html.7cacc927.js"><link rel="prefetch" href="/assets/index.html.61856ccc.js"><link rel="prefetch" href="/assets/index.html.13d9b2a2.js"><link rel="prefetch" href="/assets/index.html.7a892533.js"><link rel="prefetch" href="/assets/index.html.39aa9753.js"><link rel="prefetch" href="/assets/index.html.fa47043a.js"><link rel="prefetch" href="/assets/index.html.70f64539.js"><link rel="prefetch" href="/assets/index.html.8a900224.js"><link rel="prefetch" href="/assets/index.html.2f8da6a9.js"><link rel="prefetch" href="/assets/index.html.f29f2d41.js"><link rel="prefetch" href="/assets/index.html.7afe24e9.js"><link rel="prefetch" href="/assets/index.html.f2b7b526.js"><link rel="prefetch" href="/assets/index.html.3769743b.js"><link rel="prefetch" href="/assets/index.html.e8bd37b4.js"><link rel="prefetch" href="/assets/index.html.c6e74173.js"><link rel="prefetch" href="/assets/index.html.9534fc37.js"><link rel="prefetch" href="/assets/index.html.afecb969.js"><link rel="prefetch" href="/assets/index.html.4d8aa9d4.js"><link rel="prefetch" href="/assets/index.html.09c333b5.js"><link rel="prefetch" href="/assets/index.html.d104de07.js"><link rel="prefetch" href="/assets/index.html.3c82b2d4.js"><link rel="prefetch" href="/assets/index.html.377d5d1a.js"><link rel="prefetch" href="/assets/index.html.71d0e6ac.js"><link rel="prefetch" href="/assets/index.html.3a92fca4.js"><link rel="prefetch" href="/assets/index.html.c989a8bb.js"><link rel="prefetch" href="/assets/index.html.7b59a914.js"><link rel="prefetch" href="/assets/index.html.6a5dc56e.js"><link rel="prefetch" href="/assets/index.html.9f5c0bf5.js"><link rel="prefetch" href="/assets/index.html.75bb5516.js"><link rel="prefetch" href="/assets/index.html.f489c818.js"><link rel="prefetch" href="/assets/index.html.cec9a36d.js"><link rel="prefetch" href="/assets/index.html.eb398fe2.js"><link rel="prefetch" href="/assets/index.html.a5ee7050.js"><link rel="prefetch" href="/assets/index.html.a57f1fca.js"><link rel="prefetch" href="/assets/index.html.83229a5a.js"><link rel="prefetch" href="/assets/index.html.9a7d3d57.js"><link rel="prefetch" href="/assets/index.html.b7c06685.js"><link rel="prefetch" href="/assets/index.html.dd2aa49a.js"><link rel="prefetch" href="/assets/index.html.45452f58.js"><link rel="prefetch" href="/assets/index.html.5810ebee.js"><link rel="prefetch" href="/assets/index.html.2e8bc1c0.js"><link rel="prefetch" href="/assets/index.html.8937a325.js"><link rel="prefetch" href="/assets/index.html.12e6b546.js"><link rel="prefetch" href="/assets/index.html.0999d308.js"><link rel="prefetch" href="/assets/index.html.d6485da9.js"><link rel="prefetch" href="/assets/index.html.fb898ece.js"><link rel="prefetch" href="/assets/index.html.663fbb46.js"><link rel="prefetch" href="/assets/index.html.176f8301.js"><link rel="prefetch" href="/assets/index.html.9840c359.js"><link rel="prefetch" href="/assets/index.html.8a37c4a9.js"><link rel="prefetch" href="/assets/index.html.a6d9808e.js"><link rel="prefetch" href="/assets/index.html.01f50f90.js"><link rel="prefetch" href="/assets/index.html.abaaeb48.js"><link rel="prefetch" href="/assets/index.html.31e38e75.js"><link rel="prefetch" href="/assets/index.html.d12f3541.js"><link rel="prefetch" href="/assets/index.html.b20c1d71.js"><link rel="prefetch" href="/assets/index.html.fadef4eb.js"><link rel="prefetch" href="/assets/index.html.1fe34d92.js"><link rel="prefetch" href="/assets/index.html.6d6f578d.js"><link rel="prefetch" href="/assets/index.html.5e06dc03.js"><link rel="prefetch" href="/assets/index.html.887142cc.js"><link rel="prefetch" href="/assets/index.html.48446737.js"><link rel="prefetch" href="/assets/index.html.78772462.js"><link rel="prefetch" href="/assets/index.html.2ad922b8.js"><link rel="prefetch" href="/assets/index.html.7a7824eb.js"><link rel="prefetch" href="/assets/index.html.21e7dbb8.js"><link rel="prefetch" href="/assets/404.eafc212a.js"><link rel="prefetch" href="/assets/Layout.fb14a2eb.js"><link rel="prefetch" href="/assets/Slide.ad7d1930.js"><link rel="prefetch" href="/assets/Blog.094fba6c.js"><link rel="prefetch" href="/assets/giscus.8fe73ced.js"><link rel="prefetch" href="/assets/auto.esm.2565cd3a.js"><link rel="prefetch" href="/assets/index.d8a59108.js"><link rel="prefetch" href="/assets/index.1842ee54.js"><link rel="prefetch" href="/assets/mermaid.esm.min.ee1e0284.js"><link rel="prefetch" href="/assets/highlight.esm.d982e650.js"><link rel="prefetch" href="/assets/markdown.esm.832a189d.js"><link rel="prefetch" href="/assets/math.esm.a3f84b6f.js"><link rel="prefetch" href="/assets/notes.esm.3c361cb7.js"><link rel="prefetch" href="/assets/reveal.esm.b96f05d8.js"><link rel="prefetch" href="/assets/search.esm.80da4a02.js"><link rel="prefetch" href="/assets/zoom.esm.8514a202.js"><link rel="prefetch" href="/assets/photoswipe.esm.218074cd.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">Skip to content</a><!--]--><div class="theme-container has-toc"><!--[--><!--[--><header class="navbar"><div class="navbar-left"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!----><a href="/" class="brand"><img class="logo" src="https://img-blog.csdnimg.cn/d16e11af2edb4972833f88083d2f0375.png" alt="蝉沐风"><!----><span class="site-name hide-in-pad">蝉沐风</span></a><!----></div><div class="navbar-center"><!----><nav class="nav-links"><div class="nav-item hide-in-mobile"><a href="/" class="nav-link" aria-label="主页"><span class="icon iconfont icon-home"></span>主页<!----></a></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="技术博文"><span class="title"><span class="icon iconfont icon-xieboke"></span>技术博文</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>内功心法</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/posts/basic/design-pattern/" class="nav-link" aria-label="设计模式"><span class="icon iconfont icon-design"></span>设计模式<!----></a></li><li class="dropdown-subitem"><a href="/posts/basic/design-principle/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99.html" class="nav-link" aria-label="设计原则"><span class="icon iconfont icon-design"></span>设计原则<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>存储篇</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/posts/storage/MySQL" class="nav-link" aria-label="MySQL"><span class="icon iconfont icon-mysql"></span>MySQL<!----></a></li><li class="dropdown-subitem"><a href="/posts/storage/Redis" class="nav-link active" aria-label="Redis"><span class="icon iconfont icon-redis"></span>Redis<!----></a></li><li class="dropdown-subitem"><a href="/posts/storage/ElasticSearch" class="nav-link" aria-label="ElasticSearch"><span class="icon iconfont icon-elasticsearch-Elasticsearch"></span>ElasticSearch<!----></a></li></ul></li><li class="dropdown-item"><a href="/posts/concurrency" class="nav-link" aria-label="并发篇"><span class="icon iconfont icon-CPU"></span>并发篇<!----></a></li><li class="dropdown-item"><a href="/posts/JVM" class="nav-link" aria-label="JVM"><span class="icon iconfont icon-PCxuniji"></span>JVM<!----></a></li><li class="dropdown-item"><a href="/posts/os" class="nav-link" aria-label="Linux"><span class="icon iconfont icon-linux"></span>Linux<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="开发工具"><span class="title"><span class="icon iconfont icon-keyboard"></span>开发工具</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/posts/tools/IDEA" class="nav-link" aria-label="IDEA"><span class="icon iconfont icon-jetbrains"></span>IDEA<!----></a></li><li class="dropdown-item"><a href="/posts/tools/VSCode" class="nav-link" aria-label="VSCode"><span class="icon iconfont icon-VsCode"></span>VSCode<!----></a></li><li class="dropdown-item"><a href="/posts/tools/Mac" class="nav-link" aria-label="Mac"><span class="icon iconfont icon-mac"></span>Mac<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><a href="/posts/network-programming" class="nav-link" aria-label="socket编程"><span class="icon iconfont icon-wangluojiekou"></span>socket编程<!----></a></div><div class="nav-item hide-in-mobile"><a href="/update.html" class="nav-link" aria-label="最近更新"><span class="icon iconfont icon-Update"></span>最近更新<!----></a></div><div class="nav-item hide-in-mobile"><a href="https://space.bilibili.com/519360358" rel="noopener noreferrer" target="_blank" aria-label class="nav-link"><span class="icon iconfont icon-bilibili"></span><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div></nav><!----></div><div class="navbar-right"><!----><!----><div class="nav-item"><a class="repo-link" href="https://github.com/chanmufeng/chanmufeng.github.io" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="github icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><div id="docsearch-container"></div><!----><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow left"></span></div><aside class="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><span class="icon iconfont icon-strong"></span><span class="title">1. 持久化</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/posts/storage/Redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E2%80%94%E2%80%94AOF.html" class="nav-link sidebar-link sidebar-page" aria-label="Redis持久化——AOF"><span class="icon iconfont icon-creative"></span>Redis持久化——AOF<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/posts/storage/Redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E2%80%94%E2%80%94RDB.html" class="nav-link sidebar-link sidebar-page" aria-label="Redis持久化——RDB"><span class="icon iconfont icon-creative"></span>Redis持久化——RDB<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><span class="icon iconfont icon-condition"></span><span class="title">2. 事务</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/posts/storage/Redis/%E9%B8%A1%E8%82%8B%E7%9A%84Redis%E4%BA%8B%E5%8A%A1.html" class="nav-link sidebar-link sidebar-page" aria-label="鸡肋的Redis事务"><span class="icon iconfont icon-creative"></span>鸡肋的Redis事务<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading active"><span class="icon iconfont icon-condition"></span><span class="title">3. 高性能网络模型</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/posts/storage/Redis/BIO%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9EIO.html" class="nav-link sidebar-link sidebar-page" aria-label="BIO与非阻塞IO"><span class="icon iconfont icon-creative"></span>BIO与非阻塞IO<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-current="page" href="/posts/storage/Redis/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" aria-label="彻底搞懂IO多路复用"><span class="icon iconfont icon-creative"></span>彻底搞懂IO多路复用<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/posts/storage/Redis/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#_1-多路复用的诞生" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1. 多路复用的诞生"><!---->1. 多路复用的诞生<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/storage/Redis/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#_2-nio" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2. NIO"><!---->2. NIO<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/storage/Redis/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#_3-select" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3. select"><!---->3. select<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/posts/storage/Redis/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#_3-1-select使用方法" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.1. select使用方法"><!---->3.1. select使用方法<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/storage/Redis/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#_3-2-上限为什么是1024" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.2. 上限为什么是1024"><!---->3.2. 上限为什么是1024<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/storage/Redis/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#_3-3-nfds的作用" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.3. nfds的作用"><!---->3.3. nfds的作用<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/storage/Redis/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#_3-4-再谈阻塞" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.4. 再谈阻塞"><!---->3.4. 再谈阻塞<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/storage/Redis/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#_3-5-select如何多路复用" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.5. select如何多路复用"><!---->3.5. select如何多路复用<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/storage/Redis/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#_3-6-总结" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.6. 总结"><!---->3.6. 总结<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/storage/Redis/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#_4-poll" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4. poll"><!---->4. poll<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/posts/storage/Redis/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#_4-1-函数原型" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.1. 函数原型"><!---->4.1. 函数原型<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/storage/Redis/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#_4-2-poll订阅的事件" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.2. poll订阅的事件"><!---->4.2. poll订阅的事件<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/storage/Redis/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#_5-epoll" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5. epoll"><!---->5. epoll<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/posts/storage/Redis/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#_5-1-epoll入门" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.1. epoll入门"><!---->5.1. epoll入门<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/storage/Redis/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#_5-2-edge-triggered-和-level-triggered" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.2. edge-triggered 和 level-triggered"><!---->5.2. edge-triggered 和 level-triggered<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/storage/Redis/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#_5-3-epoll进阶" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.3. epoll进阶"><!---->5.3. epoll进阶<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/posts/storage/Redis/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#_5-4-epoll总结" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.4. epoll总结"><!---->5.4. epoll总结<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li></ul><!--]--></li><li><!--[--><a href="/posts/storage/Redis/%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E4%B8%8E%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E.html" class="nav-link sidebar-link sidebar-page" aria-label="同步异步与阻塞非阻塞"><span class="icon iconfont icon-creative"></span>同步异步与阻塞非阻塞<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><span class="icon iconfont icon-creative"></span>彻底搞懂IO多路复用</h1><div class="page-info"><span class="author-info" aria-label="作者🖊" data-balloon-pos="down" localizeddate="2023年1月31日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="author-item" href="https://www.chanmufeng.com" target="_blank" rel="noopener noreferrer">蝉沐风</a></span><span property="author" content="蝉沐风"></span></span><!----><span class="date-info" aria-label="写作日期📅" data-balloon-pos="down" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span>2023年1月31日</span><meta property="datePublished" content="2023-01-31T00:00:00.000Z"></span><span class="category-info" aria-label="分类🌈" data-balloon-pos="down" localizeddate="2023年1月31日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon category-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="category icon"><path d="M148.41 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H148.41c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.311-40.31zM147.556 553.478H429.73c22.263 0 40.311 18.048 40.311 40.31v282.176c0 22.263-18.048 40.312-40.31 40.312H147.555c-22.263 0-40.311-18.049-40.311-40.312V593.79c0-22.263 18.048-40.311 40.31-40.311zM593.927 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H593.927c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.31-40.31zM730.22 920.502H623.926c-40.925 0-74.22-33.388-74.22-74.425V623.992c0-41.038 33.387-74.424 74.425-74.424h222.085c41.038 0 74.424 33.226 74.424 74.067v114.233c0 10.244-8.304 18.548-18.547 18.548s-18.548-8.304-18.548-18.548V623.635c0-20.388-16.746-36.974-37.33-36.974H624.13c-20.585 0-37.331 16.747-37.331 37.33v222.086c0 20.585 16.654 37.331 37.126 37.331H730.22c10.243 0 18.547 8.304 18.547 18.547 0 10.244-8.304 18.547-18.547 18.547z"></path></svg><ul class="categories-wrapper"><li class="category category3 clickable" role="navigation">Redis</li><meta property="articleSection" content="Redis"></ul></span><span aria-label="标签🏷" data-balloon-pos="down" localizeddate="2023年1月31日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon tag-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="tag icon"><path d="M939.902 458.563L910.17 144.567c-1.507-16.272-14.465-29.13-30.737-30.737L565.438 84.098h-.402c-3.215 0-5.726 1.005-7.634 2.913l-470.39 470.39a10.004 10.004 0 000 14.164l365.423 365.424c1.909 1.908 4.42 2.913 7.132 2.913s5.223-1.005 7.132-2.913l470.39-470.39c2.01-2.11 3.014-5.023 2.813-8.036zm-240.067-72.121c-35.458 0-64.286-28.828-64.286-64.286s28.828-64.285 64.286-64.285 64.286 28.828 64.286 64.285-28.829 64.286-64.286 64.286z"></path></svg><ul class="tags-wrapper"><li class="tag tag3 clickable" role="navigation">多路复用</li><li class="tag tag6 clickable" role="navigation">select</li><li class="tag tag1 clickable" role="navigation">poll</li><li class="tag tag8 clickable" role="navigation">epoll</li></ul><meta property="keywords" content="多路复用,select,poll,epoll"></span><span class="reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down" localizeddate="2023年1月31日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 38 分钟</span><meta property="timeRequired" content="PT38M"></span><!----><span class="words-info" aria-label="字数🔠" data-balloon-pos="down" localizeddate="2023年1月31日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon word-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="word icon"><path d="M518.217 432.64V73.143A73.143 73.143 0 01603.43 1.097a512 512 0 01419.474 419.474 73.143 73.143 0 01-72.046 85.212H591.36a73.143 73.143 0 01-73.143-73.143z"></path><path d="M493.714 566.857h340.297a73.143 73.143 0 0173.143 85.577A457.143 457.143 0 11371.566 117.76a73.143 73.143 0 0185.577 73.143v339.383a36.571 36.571 0 0036.571 36.571z"></path></svg><span>约 11478 字</span><meta property="wordCount" content="11478"></span></div><hr></div><div class="toc-place-holder"><aside id="toc"><div class="toc-header">此页内容</div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/posts/storage/Redis/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#_1-多路复用的诞生" class="router-link-active router-link-exact-active toc-link level2">1. 多路复用的诞生</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/storage/Redis/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#_2-nio" class="router-link-active router-link-exact-active toc-link level2">2. NIO</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/storage/Redis/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#_3-select" class="router-link-active router-link-exact-active toc-link level2">3. select</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/posts/storage/Redis/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#_3-1-select使用方法" class="router-link-active router-link-exact-active toc-link level3">3.1. select使用方法</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/storage/Redis/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#_3-2-上限为什么是1024" class="router-link-active router-link-exact-active toc-link level3">3.2. 上限为什么是1024</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/storage/Redis/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#_3-3-nfds的作用" class="router-link-active router-link-exact-active toc-link level3">3.3. nfds的作用</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/storage/Redis/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#_3-4-再谈阻塞" class="router-link-active router-link-exact-active toc-link level3">3.4. 再谈阻塞</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/storage/Redis/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#_3-5-select如何多路复用" class="router-link-active router-link-exact-active toc-link level3">3.5. select如何多路复用</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/storage/Redis/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#_3-6-总结" class="router-link-active router-link-exact-active toc-link level3">3.6. 总结</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/storage/Redis/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#_4-poll" class="router-link-active router-link-exact-active toc-link level2">4. poll</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/posts/storage/Redis/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#_4-1-函数原型" class="router-link-active router-link-exact-active toc-link level3">4.1. 函数原型</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/storage/Redis/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#_4-2-poll订阅的事件" class="router-link-active router-link-exact-active toc-link level3">4.2. poll订阅的事件</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/storage/Redis/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#_5-epoll" class="router-link-active router-link-exact-active toc-link level2">5. epoll</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/posts/storage/Redis/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#_5-1-epoll入门" class="router-link-active router-link-exact-active toc-link level3">5.1. epoll入门</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/storage/Redis/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#_5-2-edge-triggered-和-level-triggered" class="router-link-active router-link-exact-active toc-link level3">5.2. edge-triggered 和 level-triggered</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/storage/Redis/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#_5-3-epoll进阶" class="router-link-active router-link-exact-active toc-link level3">5.3. epoll进阶</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/storage/Redis/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html#_5-4-epoll总结" class="router-link-active router-link-exact-active toc-link level3">5.4. epoll总结</a></li><!----><!--]--></ul><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><p><a href="https://mp.weixin.qq.com/s?__biz=MzI1MDU0MTc2MQ==&amp;mid=2247484866&amp;idx=1&amp;sn=b23a095736a130a00b2e434d0328ba83&amp;chksm=e981e66cdef66f7a39f6c3aefa44430b202e1a3419dfe3dd90e342832a213f2887fd202413bc#rd" target="_blank" rel="noopener noreferrer">上一篇文章<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>以近乎啰嗦的方式详细描述了BIO与非阻塞IO的各种细节。如果各位还没有读过这篇文章，强烈建议先阅读一下，然后再来看本篇，因为逻辑关系是层层递进的。</p><p><img src="https://qiniu.chanmufeng.com/2023-01-31-052353.png" alt="" loading="lazy"></p><h2 id="_1-多路复用的诞生" tabindex="-1"><a class="header-anchor" href="#_1-多路复用的诞生" aria-hidden="true">#</a> 1. 多路复用的诞生</h2><p>非阻塞IO使用一个线程就可以处理所有socket，但是付出的代价是必须频繁调用系统调用来轮询每一个socket的数据，这种轮询太耗费性能，而且大部分轮询都是空轮询。</p><p>我们希望有个组件能同时监控多个socket，并在socket把数据准备好的时候告诉进程哪些socket已“<strong>就绪</strong>”，然后进程只对就绪的socket进行数据读写。</p><p>Java在JDK1.4的时候引入了NIO，并提供了<code>Selector</code>这个组件来实现这个功能。</p><h2 id="_2-nio" tabindex="-1"><a class="header-anchor" href="#_2-nio" aria-hidden="true">#</a> 2. NIO</h2><p>在引入NIO代码之前，有点事情需要解释一下。</p><p>“<strong>就绪</strong>”这个词用得有点暧昧，因为不同的socket对就绪有不同的表达。比如对于监听socket而言，如果有客户端对其进行了连接，就说明处于就绪状态，它并不像连接socket一样，需要对数据的收发进行处理；相反，连接socket的就绪状态就至少包含了<strong>数据准备好读</strong>（<em>is ready for reading</em>）与<strong>数据准备好写</strong>（<em>is ready for writing</em>）这两种。</p><p>因此，可以想象，我们让<code>Selector</code>对多个socket进行监听时，必然需要告诉<code>Selector</code>，我们对哪些socket的哪些事件感兴趣。这个动作叫注册。</p><p>接下来看代码。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NIOServer</span> <span class="token punctuation">{</span>

    <span class="token keyword">static</span> <span class="token class-name">Selector</span> selector<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment">// 获得selector多路复用器</span>
            selector <span class="token operator">=</span> <span class="token class-name">Selector</span><span class="token punctuation">.</span><span class="token keyword">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token class-name">ServerSocketChannel</span> serverSocketChannel <span class="token operator">=</span> <span class="token class-name">ServerSocketChannel</span><span class="token punctuation">.</span><span class="token keyword">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 监听socket的accept将不会阻塞</span>
            serverSocketChannel<span class="token punctuation">.</span><span class="token function">configureBlocking</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            serverSocketChannel<span class="token punctuation">.</span><span class="token function">socket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InetSocketAddress</span><span class="token punctuation">(</span><span class="token number">8099</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment">// 需要把监听socket注册到多路复用器上，并告诉selector，需要关注监听socket的OP_ACCEPT事件</span>
            serverSocketChannel<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>selector<span class="token punctuation">,</span> <span class="token class-name">SelectionKey</span><span class="token punctuation">.</span>OP_ACCEPT<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 该方法会阻塞</span>
                selector<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token comment">// 得到所有就绪的事件，事件被封装成了SelectionKey</span>
                <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SelectionKey</span><span class="token punctuation">&gt;</span></span> selectionKeys <span class="token operator">=</span> selector<span class="token punctuation">.</span><span class="token function">selectedKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SelectionKey</span><span class="token punctuation">&gt;</span></span> iterator <span class="token operator">=</span> selectionKeys<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token class-name">SelectionKey</span> key <span class="token operator">=</span> iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    iterator<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">isAcceptable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token function">handleAccept</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">isReadable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token function">handleRead</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">isWritable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token comment">//发送数据</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>

            <span class="token punctuation">}</span>

        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
		
    <span class="token comment">// 处理「读」事件的业务逻辑</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">handleRead</span><span class="token punctuation">(</span><span class="token class-name">SelectionKey</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">SocketChannel</span> socketChannel <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">SocketChannel</span><span class="token punctuation">)</span> key<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">ByteBuffer</span> allocate <span class="token operator">=</span> <span class="token class-name">ByteBuffer</span><span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            socketChannel<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>allocate<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;From Client:&quot;</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>allocate<span class="token punctuation">.</span><span class="token function">array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

    <span class="token punctuation">}</span>

  	<span class="token comment">// 处理「连接」事件的业务逻辑</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">handleAccept</span><span class="token punctuation">(</span><span class="token class-name">SelectionKey</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">ServerSocketChannel</span> serverSocketChannel <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ServerSocketChannel</span><span class="token punctuation">)</span> key<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment">// socketChannel一定是非空，并且这里不会阻塞</span>
            <span class="token class-name">SocketChannel</span> socketChannel <span class="token operator">=</span> serverSocketChannel<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 将连接socket的读写设置为非阻塞</span>
            socketChannel<span class="token punctuation">.</span><span class="token function">configureBlocking</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            socketChannel<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token class-name">ByteBuffer</span><span class="token punctuation">.</span><span class="token function">wrap</span><span class="token punctuation">(</span><span class="token string">&quot;Hello Client， I am Server！&quot;</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 注册连接socket的「读事件」</span>
            socketChannel<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>selector<span class="token punctuation">,</span> <span class="token class-name">SelectionKey</span><span class="token punctuation">.</span>OP_READ<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们首先使用<code>Selector.open();</code>得到了<code>selector</code>这个多路复用对象；然后在服务端创建了监听socket，并将其设置为<strong>非阻塞</strong>，最后将监听socket注册到<code>selector</code>多路复用器上，并告诉<code>selector</code>，如果监听socket有<code>OP_ACCEPT</code>事件发生的话就要告诉我们。</p><p>我们在while循环中调用<code>selector.select();</code>方法，进程将会阻塞在该方法上，直到注册在<code>selector</code>上的任意一个socket有事件发生为止，才会返回。如果不信的话可以在<code>selector.select();</code>的下一行打个断点，debug模式运行后，在没有客户端连接的情况下断点不会被触发。</p><p>当<code>select()</code>返回，意味着有一个或多个socket已经处于就绪状态，我们使用<code>Set&lt;SelectionKey&gt;</code>来保存所有事件，<code>SelectionKey</code>封装了就绪的事件，我们循环每个事件，根据不同的事件类型进行不同的业务逻辑处理。</p><p><code>OP_READ</code>事件就绪的话，我们就准备一个缓冲空间，将数据从内核空间读到缓冲中；如果是<code>OP_ACCEPT</code>就绪，那就调用监听socket的<code>accept()</code>方法得到连接socket，并且<code>accept()</code>不会阻塞，因为在最开始的时候我们已经将监听socket设置为非阻塞了。得到的连接socket同样需要设置为非阻塞，这样连接socket的读写操作就是非阻塞的，最后将连接socket注册到<code>selector</code>多路复用器上，并告诉<code>selector</code>，如果连接socket有<code>OP_READ</code>事件发生的话就要告诉我们。</p><p>上个动图对Java的多路复用代码做个解释。</p><p><img src="https://qiniu.chanmufeng.com/2023-01-02-150949.gif" alt="多路复用" loading="lazy"></p><p>接下来的重点自然是NIO中的<code>select()</code>的底层原理了，还是那句话，NIO之所以能提供多路复用的功能，本质上还是操作系统底层提供了多路复用的系统调用。</p><p>多路复用本质上就是同时监听多个socket的请求，当我们订阅的socket上有我们感兴趣的事件发生的时候，多路复用函数会返回，然后我们的用户程序根据返回结果继续处理这些就绪状态的socket。</p><p>但是，不同的多路复用模型在具体的实现上有所不同，主要体现在三个方面：</p><ol><li>多路复用模型最多可以同时监听多少个socket？</li><li>多路复用模型会监听socket上哪些事件？</li><li>当socket就绪时，多路复用模型如何找到就绪的socket？</li></ol><p>多路复用主要有3种，分别是<code>select</code>、<code>poll</code>和<code>epoll</code>，接下来将带着上面3个问题分别介绍这3种底层模型。</p><blockquote><p>下文相关函数的声明以及参数的定义源于64位CentOS 7.9，内核版本为3.10.0</p></blockquote><h2 id="_3-select" tabindex="-1"><a class="header-anchor" href="#_3-select" aria-hidden="true">#</a> 3. select</h2><p>我们可以通过<code>select</code>告诉内核，我们对哪些描述符（这些描述符可以表示标准输入、监听socket或者连接socket等）的哪些事件（可读、可写、发生异常）感兴趣，或者某个超时时间之后直接返回。</p><p>举个例子，我们调用<code>select</code>告诉内核仅在下列情况下发生时才返回：</p><ul><li>集合{1, 4, 7}中有任何描述符<strong>读</strong>就绪；</li><li>集合{2, 9}中有任何描述符<strong>写</strong>就绪；</li><li>集合{1, 3, 5}中有任何描述符<strong>有异常发生</strong>；</li><li>超过了10S，啥事儿也没有发生。</li></ul><h3 id="_3-1-select使用方法" tabindex="-1"><a class="header-anchor" href="#_3-1-select使用方法" aria-hidden="true">#</a> 3.1. select使用方法</h3><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">// 返回：若有就绪描述符则为其数目，若超时则为0，若出错则为-1</span>
<span class="token keyword">int</span> <span class="token function">select</span><span class="token punctuation">(</span><span class="token keyword">int</span> nfds<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>readfds<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>writefds<span class="token punctuation">,</span>
                  fd_set <span class="token operator">*</span>exceptfds<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">timeval</span> <span class="token operator">*</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>nfds</code>参数用来告诉<code>select</code>需要检查的描述符的个数，取值为我们感兴趣的最大描述符 + 1，按照刚才的例子来讲<code>nfds</code>应该是<code>{{1, 4, 7}, {2, 9}, {1, 3, 5}}</code>中的最大描述符+1，也就是9 + 1，为10。至于为什么这样，别急，我们下文再说。</p><p><code>timeout</code>参数允许我们设置<code>select</code>的超时时间，如果超过指定时间还没有我们感兴趣的事件发生，就停止阻塞，直接返回。</p><p><code>readfds</code>里保存的是我们对<strong>读就绪事件</strong>感兴趣的描述符，<code>writefds</code>保存的是我们对<strong>写就绪事件</strong>感兴趣的描述符，<code>exceptfds</code>保存的是我们对<strong>发生异常</strong>这种事件感兴趣的描述符。这三个参数会告诉内核，分别需要在哪些描述符上检测数据可读、可写以及发生异常。</p><p>但是这些描述符并非像我的例子一样，直接把集合<code>{1, 4, 7}</code>作为数组存起来，设计者从内存空间和使用效率的角度设计了<code>fd_set</code>这个数据结构，我们看一下它的定义以及某些重要信息。</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">// file: /usr/include/sys/select.h</span>
<span class="token comment">/* __fd_mask 是 long int 类型的别名  */</span>
<span class="token keyword">typedef</span> <span class="token keyword">long</span> <span class="token keyword">int</span> __fd_mask<span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__NFDBITS</span>	<span class="token expression"><span class="token punctuation">(</span><span class="token number">8</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token keyword">sizeof</span> <span class="token punctuation">(</span>__fd_mask<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span>  <span class="token punctuation">{</span>
   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
   __fd_mask fds_bits<span class="token punctuation">[</span>__FD_SETSIZE <span class="token operator">/</span> __NFDBITS<span class="token punctuation">]</span><span class="token punctuation">;</span>
   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span> fd_set<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因此，<code>fd_set</code>的定义，其实就是<code>long int</code>类型的数组，元素个数为<code>__FD_SETSIZE / __NFDBITS</code>，我直接在我的CentOS上输出了一下两个常量值，如下：</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&quot;sys/select.h&quot;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;__FD_SETSIZE:%d\n&quot;</span><span class="token punctuation">,</span>__FD_SETSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;__NFDBITS:%d\n&quot;</span><span class="token punctuation">,</span>__NFDBITS<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 输出结果</span>
__FD_SETSIZE<span class="token operator">:</span><span class="token number">1024</span>
__NFDBITS<span class="token operator">:</span><span class="token number">64</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因此该数组中一共有16个元素（1024 / 64 = 16），每个元素为long int类型，占64位。</p><p>数组的第<code>1</code>个元素用于表示描述符<code>0～63</code>，第<code>2</code>个元素用于表示描述符<code>64～127</code>，以此类推，每1个bit位用<code>0</code>、<code>1</code>两种状态表示是否检测当前描述符的事件。</p><p>假设我们对<code>{1, 4, 7}</code>号描述符的读就绪事件感兴趣，那么<code>readfds</code>参数的数组第1个元素的二进制表示就如下图所示，第1、4、7位分别被标记为1，实际存储的10进制数字为146。</p><p><img src="https://qiniu.chanmufeng.com/2023-01-11-015644.png" alt="" loading="lazy"></p><p>实际使用<code>select</code>的时候如果让我们自己推导上面这个过程进行参数设置那可费了劲了，于是操作系统提供了4个宏来帮我们设置数组中每个元素的每一位。</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">// 将数组每个元素的二进制位重置为0</span>
<span class="token keyword">void</span> <span class="token function">FD_ZERO</span><span class="token punctuation">(</span>fd_set <span class="token operator">*</span>fdset<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 将第fd个描述符表示的二进制位设置为1</span>
<span class="token keyword">void</span> <span class="token function">FD_SET</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>fdset<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 将第fd个描述符表示的二进制位设置为0</span>
<span class="token keyword">void</span> <span class="token function">FD_CLR</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>fdset<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 检查第fd个描述符表示的二进制位是0还是1</span>
<span class="token keyword">int</span>  <span class="token function">FD_ISSET</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>fdset<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>还是上面<code>{1, 4, 7}</code>这个例子，再顺带着介绍一下用法，知道有这么回事儿就行了。</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code>fd_set readSet<span class="token punctuation">;</span>
<span class="token function">FD_ZERO</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>readSet<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">FD_SET</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>readSet<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">FD_SET</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>readSet<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">FD_SET</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>readSet<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>既然<code>fd_set</code>底层用的是数组，那就一定有长度限制，也就是说<strong>select同时监听的socket数量是有限的</strong>，你之前可能听过这个有限的数量是<code>1024</code>，但是<code>1024</code>是怎么来的呢？</p><h3 id="_3-2-上限为什么是1024" tabindex="-1"><a class="header-anchor" href="#_3-2-上限为什么是1024" aria-hidden="true">#</a> 3.2. 上限为什么是1024</h3><p>其实<code>select</code>的监听上限就等于<code>fds_bits</code>数组中所有元素的二进制位总数。接下来我们用初中数学的解题步骤推理一下这个二进制位到底有多少。</p><p><em>已知：</em></p><p><img src="https://qiniu.chanmufeng.com/2023-01-11-024255.png" alt="" loading="lazy"></p><p><em>证明如下：</em></p><p><img src="https://qiniu.chanmufeng.com/2023-01-11-033732.png" alt="" loading="lazy"></p><p>结论就是<code>__FD_SETSIZE</code>这个宏其实就是<code>select</code>同时监听socket的最大数量。该数值在源码中有定义，如下所示：</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">// file: /usr/include/bits/typesizes.h</span>
<span class="token comment">/* Number of descriptors that can fit in an `fd_set&#39;.  */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__FD_SETSIZE</span>		<span class="token expression"><span class="token number">1024</span></span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所以，<strong>select函数对每一个描述符集合fd_set，最多可以同时监听1024个描述符</strong>。</p><h3 id="_3-3-nfds的作用" tabindex="-1"><a class="header-anchor" href="#_3-3-nfds的作用" aria-hidden="true">#</a> 3.3. nfds的作用</h3><p>为什么偏偏把最大值设置成<code>1024</code>呢？没人知道，或许只是程序员喜欢这个数字罢了。</p><p>最初设计<code>select</code>的时候，设计者考虑到大多数的应用程序根本不会用到很多的描述符，因此最大描述符的上限被设置成了<code>31</code>（4.2BSD版本），后来在4.4BSD中被设置成了<code>256</code>，直到现在被设置成了<code>1024</code>。</p><p>这个数量说多不多，说少也不算少，<code>select()</code>需要循环遍历数组中的位判断此描述符是否有对应的事件发生，如果每次都对<code>1024</code>个描述符进行判断，在我们感兴趣的监听描述符比较少的情况下（比如我上文的例子）那就是一种极大的浪费。于是，<code>select</code>给我们提供了<code>nfds</code>这个参数，让我们告诉<code>select()</code>只需要迭代数组中的前<code>nfds</code>个就行了，而不要总是在每次调用的时候遍历整个数组。</p><p><strong>身为一个系统函数，执行效率自然需要优化到极致</strong>。</p><h3 id="_3-4-再谈阻塞" tabindex="-1"><a class="header-anchor" href="#_3-4-再谈阻塞" aria-hidden="true">#</a> 3.4. 再谈阻塞</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzI1MDU0MTc2MQ==&amp;mid=2247484866&amp;idx=1&amp;sn=b23a095736a130a00b2e434d0328ba83&amp;chksm=e981e66cdef66f7a39f6c3aefa44430b202e1a3419dfe3dd90e342832a213f2887fd202413bc#rd" target="_blank" rel="noopener noreferrer">上一篇文章<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>讲过，当用户线程发起一个阻塞式的read系统调用，数据未就绪时，线程就会阻塞。阻塞其实是调用线程被投入睡眠，直到内核在某个时机唤醒线程，阻塞也就结束。这里我们借着<code>select</code>再聊一聊这个阻塞。</p><blockquote><p>本小节中不做「进程」和「线程」的明确区分，线程作为轻量级进程来看待</p></blockquote><p>内核会为每一个进程创建一个名为<code>task_struct</code>的数据结构，这个数据结构本身是分配在内核空间的，其中保存了当前进程的进程号、socket信息、CPU的运行上下文以及其他很重要但是我不讲的信息（/狗头）。</p><p>Linux内核维护了一个<strong>执行队列</strong>，里边放的都是处于<code>TASK_RUNNING</code>状态的进程的<code>task_struct</code>，这些进程以双向链表的方式排队等待CPU极短时间的临幸。</p><p><img src="https://qiniu.chanmufeng.com/2023-01-12-014945.png" alt="进程在执行队列" loading="lazy"></p><p>阻塞的本质就是将进程的<code>task_struct</code>移出执行队列，让出CPU的调度，将进程的状态的置为<code>TASK_UNINTERRUPTIBLE</code>或者<code>TASK_INTERRUPTIBLE</code>，然后添加到<strong>等待队列</strong>中，直到被唤醒。</p><p>那这个等待队列在哪儿呢？比如我们对一个socket发起一个阻塞式的 <code>read</code> 调用，用户进程肯定是需要和这个socket进行绑定的，要不然socket就绪之后都不知道该唤醒谁。这个等待队列其实就是保存在socket数据结构中，我们瞄一眼socket源码：</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">socket</span> <span class="token punctuation">{</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token comment">// 这个在epoll中会提到</span>
	<span class="token keyword">struct</span> <span class="token class-name">file</span>		<span class="token operator">*</span>file<span class="token punctuation">;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token comment">// struct sock - network layer representation of sockets</span>
	<span class="token keyword">struct</span> <span class="token class-name">sock</span>		<span class="token operator">*</span>sk<span class="token punctuation">;</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token punctuation">{</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token comment">// incoming packets</span>
	<span class="token keyword">struct</span> <span class="token class-name">sk_buff_head</span>	sk_receive_queue<span class="token punctuation">;</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token comment">// Packet sending queue</span>
	<span class="token keyword">struct</span> <span class="token class-name">sk_buff_head</span>	sk_write_queue<span class="token punctuation">;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token comment">// socket的等待队列，wq的意思就是wait_queue</span>
  <span class="token keyword">struct</span> <span class="token class-name">socket_wq</span> __rcu	<span class="token operator">*</span>sk_wq<span class="token punctuation">;</span>
	
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://qiniu.chanmufeng.com/2023-01-28-081300.png" alt="socket数据结构" loading="lazy"></p><p>不用深入理解哈，只要知道socket自己维护了一个等待队列<code>sk_wq</code>，这个队列中每个元素保存的是：</p><ul><li>阻塞在当前socket上的进程描述符</li><li>进程被唤醒之后应该调用的回调函数</li></ul><p>这个回调函数是进程在加入等待队列的时候设置的一个函数指针（行话叫，向内核注册了一个回调函数），告诉内核：我正等着这个socket上的数据呢，先睡一会儿，等有数据了你就执行这个回调函数吧，里边有把我唤醒的逻辑。</p><p>就这样，经过网卡接收数据、硬中断以及软中断再到内核调用回调函数唤醒进程，把进程的<code>task_struct</code>从等待队列移动到执行队列，进程再次得到CPU的临幸，函数返回结果，阻塞结束。</p><p>现在回到<code>select</code>。</p><p>用户进程会阻塞在<code>select</code>之上，由于<code>select</code>会同时监听多个socket，因此当前进程会被添加到每个被监听的socket的等待队列中，每次唤醒还需要从每个socket等待队列中移除。</p><p><img src="https://qiniu.chanmufeng.com/2023-01-12-044606.png" alt="select的阻塞与唤醒" loading="lazy"></p><p><code>select</code>的唤醒也有个问题，调用<code>select</code>的进程被唤醒之后是一脸懵啊，内核直接扔给他一个整数，进程不知道哪些socket收到数据了，还必须遍历一下才能知道。</p><p><img src="https://qiniu.chanmufeng.com/2023-01-12-025446.gif" alt="刚睡醒，一脸懵" loading="lazy"></p><h3 id="_3-5-select如何多路复用" tabindex="-1"><a class="header-anchor" href="#_3-5-select如何多路复用" aria-hidden="true">#</a> 3.5. select如何多路复用</h3><p><code>select</code>在超时时间内会被阻塞，直到我们感兴趣的socket读就绪、写就绪或者有异常事件发生（这话好像啰嗦了好多遍了，是不是自然而然已经记住了），然后<code>select</code>会返回已就绪的描述符数。</p><blockquote><p>其实<strong>读就绪</strong>、<strong>写就绪</strong>或者<strong>有异常事件发生</strong>这3种事件里边的道道儿非常多，这里我们就仅作字面上的理解就好了，更多细节，可以参考《Unix网络编程 卷一》。</p></blockquote><p>用户进程拿到这个整数说明了两件事情：</p><ol><li>我们上文讲的所有<code>select</code>操作都是在内核态运行的，<code>select</code>返回之后，权限交还到了用户空间；</li><li>用户进程拿到这个整数，需要对<code>select</code>监听的描述符逐个进行检测，判断二进制位是否被设置为1，进而进行相关的逻辑处理。可是问题是，内核把“就绪”的这个状态保存在了哪里呢？换句话说，用户进程该遍历谁？</li></ol><p><code>select</code>的<code>readfds</code>、<code>writefds</code>、<code>exceptfds</code> 3个参数都是指针类型，用户进程传递这3个参数告诉内核对哪些socket的哪些事件感兴趣，执行完毕之后反过来内核会将就绪的描述符状态也放在这三个参数变量中，这种参数称为<strong>值-结果</strong>参数。</p><p>用户进程通过调用<code>FD_ISSET(int fd, fd_set *fdset)</code>对描述符集进行判断即可，看个整体流程的动图。</p><p><img src="https://qiniu.chanmufeng.com/2023-01-11-120008.gif" alt="select动图" loading="lazy"></p><ul><li><p>用户进程设置<code>fd_set</code>参数，调用<code>select()</code>函数，并将描述符集合拷贝到内核空间；</p></li><li><p>为了提高效率，内核通过<code>nfds</code>参数避免检测那些总为<code>0</code>的位，遍历的过程发生在内核空间，不存在系统调用切换上下文的开销；</p></li><li><p><code>select</code>函数修改由指针<code>readset</code>、<code>writeset</code>以及<code>exceptset</code>所指向的描述符集，函数返回时，描述符集中只有之前我们标记过的并且处于就绪状态的描述符对应的二进制位才是1，其余都会被重置为0（因此每次重新调用<code>select</code>时，我们必须把所有描述符集中感兴趣的位再次设置为1）；</p></li><li><p>进程根据<code>select()</code>返回的结果判断操作是否正常，如果为<code>0</code>表示超时，<code>-1</code>表示出错，大于<code>0</code>表示有相应数量的描述符就绪了，进而利用<code>FD_ISSET</code>遍历检查所有相应类型的<code>fd_set</code>中的所有描述符，如果为<code>1</code>，则进行业务逻辑处理即可。</p></li></ul><h3 id="_3-6-总结" tabindex="-1"><a class="header-anchor" href="#_3-6-总结" aria-hidden="true">#</a> 3.6. 总结</h3><p>select（包括下文讲到的poll）是阻塞的，进程会阻塞在select之上，而不是阻塞在真正的I/O系统调用上，模型示意图见下图：</p><p><img src="https://qiniu.chanmufeng.com/2023-01-02-020526.png" alt="I/O多路复用模型" loading="lazy"></p><p>我们从头到尾都是使用一个用户线程来处理所有socket，同时又避免了非阻塞IO的那种无效轮询，为此付出的代价是一次<code>select</code>系统调用的阻塞，外加N次就绪文件描述符的系统调用。</p><h2 id="_4-poll" tabindex="-1"><a class="header-anchor" href="#_4-poll" aria-hidden="true">#</a> 4. poll</h2><p><code>poll</code>是<code>select</code>的继任者，接下来聊它。</p><h3 id="_4-1-函数原型" tabindex="-1"><a class="header-anchor" href="#_4-1-函数原型" aria-hidden="true">#</a> 4.1. 函数原型</h3><p>先看一下函数原型：</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">// 返回：若有就绪描述符则为其数目，若超时则为0，若出错则为-1</span>
<span class="token keyword">int</span> <span class="token function">poll</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pollfd</span> <span class="token operator">*</span>fds<span class="token punctuation">,</span> <span class="token class-name">nfds_t</span> nfds<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>函数有3个参数，第一个参数是一个<code>pollfd</code>类型的数组，其中<code>pollfd</code>结构如下：</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">pollfd</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span>    fd<span class="token punctuation">;</span>       <span class="token comment">/* file descriptor */</span>
    <span class="token keyword">short</span>  events<span class="token punctuation">;</span>   <span class="token comment">/* events to look for */</span>
    <span class="token keyword">short</span>  revents<span class="token punctuation">;</span>  <span class="token comment">/* events returned */</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4-2-poll订阅的事件" tabindex="-1"><a class="header-anchor" href="#_4-2-poll订阅的事件" aria-hidden="true">#</a> 4.2. poll订阅的事件</h3><p><code>pollfd</code>由3部分组成，首先是描述符<code>fd</code>，其次<code>events</code>表示描述符<code>fd</code>上待检测的事件类型，一个<code>short</code>类型的数字用来表示多种事件，自然可以想到用的是二进制掩码的方式来进行位操作。</p><p>源码中我们可以找到所有事件的定义，我根据事件的分类对源码的顺序做了一定调整，如下：</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">// file: /usr/include/bits/poll.h</span>
<span class="token comment">/* 第一类：可读事件  */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">POLLIN</span>		<span class="token expression"><span class="token number">0x001</span>		</span><span class="token comment">/* There is data to read.  */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">POLLPRI</span>		<span class="token expression"><span class="token number">0x002</span>		</span><span class="token comment">/* There is urgent data to read.  */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">POLLRDNORM</span>	<span class="token expression"><span class="token number">0x040</span>		</span><span class="token comment">/* Normal data may be read.  */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">POLLRDBAND</span>	<span class="token expression"><span class="token number">0x080</span>		</span><span class="token comment">/* Priority data may be read.  */</span></span>


<span class="token comment">/* 第二类：可写事件  */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">POLLOUT</span>		<span class="token expression"><span class="token number">0x004</span>		</span><span class="token comment">/* Writing now will not block.  */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">POLLWRNORM</span>	<span class="token expression"><span class="token number">0x100</span>		</span><span class="token comment">/* Writing now will not block.  */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">POLLWRBAND</span>	<span class="token expression"><span class="token number">0x200</span>		</span><span class="token comment">/* Priority data may be written.  */</span></span>


<span class="token comment">/* 第三类：错误事件 */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">POLLERR</span>		<span class="token expression"><span class="token number">0x008</span>		</span><span class="token comment">/* Error condition.  */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">POLLHUP</span>		<span class="token expression"><span class="token number">0x010</span>		</span><span class="token comment">/* Hung up.  */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">POLLNVAL</span>	<span class="token expression"><span class="token number">0x020</span>		</span><span class="token comment">/* Invalid polling request.  */</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>pollfd</code>结构中还有一个<code>revents</code>字段，全称是“returned events”，这是<code>poll</code>与<code>select</code>的第1个不同点。</p><p><strong>poll会将每次遍历之后的结果保存到revents字段中，没有select那种值-结果参数，也就不需要每次调用poll的时候重置我们感兴趣的描述符以及相关事件。</strong></p><p>还有一点，<strong>错误事件不能在events中进行设置，但是当相应事件发生时会通过revents字段返回</strong>。这是<code>poll</code>与<code>select</code>的第2个不同点。</p><p>再来看<code>poll</code>的第2个参数<code>nfds</code>，表示的是数组<code>fds</code>的元素个数，也就是用户进程想让<code>poll</code>同时监听的描述符的个数。</p><p>如此一来，<strong>poll函数将设置最大监听数量的权限给了程序设计者，自由控制pollfd结构数组的大小，突破了select函数1024个最大描述符的限制</strong>。这是<code>poll</code>与<code>select</code>的第3个不同点。</p><p>至于<code>timeout</code>参数就更好理解了，就是设置超时时间罢了，更多细节朋友们可以查看一下api。</p><p><code>poll</code>和<code>select</code>是完全不同的API设计，因此要说不同点那真是海了去了，但是由于本质上和<code>select</code>没有太大的变化，因此我们也只关注上面的这几个不同点也就罢了。需要注意的是<code>poll</code>函数返回之后，被唤醒的用户进程依然是懵的，踉踉跄跄地去遍历文件描述符、检查相关事件、进行相应逻辑处理。</p><p>其他的细节就再参考一下<code>select</code>吧，<code>poll</code>我们到此为止。</p><h2 id="_5-epoll" tabindex="-1"><a class="header-anchor" href="#_5-epoll" aria-hidden="true">#</a> 5. epoll</h2><p><code>epoll</code>是三者之中最强大的多路复用模型，自然也更难讲，要三言两语只讲一下<code>epoll</code>的优势倒也不难，不过会丧失很多细节，用源码解释又太枯燥，思来想去，于是。。。</p><p>我拖更了。。。</p><p><img src="https://qiniu.chanmufeng.com/2023-01-28-084416.png" alt="都是epoll的锅" loading="lazy"></p><h3 id="_5-1-epoll入门" tabindex="-1"><a class="header-anchor" href="#_5-1-epoll入门" aria-hidden="true">#</a> 5.1. epoll入门</h3><p>还是先从<code>epoll</code>的函数使用开始，不同<code>于select/poll</code>单个函数走天下，<code>epoll</code>用起来稍微麻烦了一点点，它提供了函数三件套，<code>epoll_create</code>、<code>epoll_ctl</code>、<code>epoll_wait</code>，我们一个个来看。</p><h4 id="_5-1-1-创建epoll实例" tabindex="-1"><a class="header-anchor" href="#_5-1-1-创建epoll实例" aria-hidden="true">#</a> 5.1.1. 创建epoll实例</h4><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">// size参数从Linux2.6.8之后失去意义，为保持向前兼容，需要使size参数 &gt; 0</span>
<span class="token keyword">int</span> <span class="token function">epoll_create</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 这个函数是最新款，如果falgs为0，等同于epoll_create()</span>
<span class="token keyword">int</span> <span class="token function">epoll_create1</span><span class="token punctuation">(</span><span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>epoll_create()</code> 方法创建了一个 epoll 实例，并返回了指向epoll实例的描述符，这个描述符用于下文即将介绍的另外两个函数。也可以使用<code>epoll_create1()</code>这个新函数，这个函数相比前者可以多添加<code>EPOLL_CLOEXEC</code>这个可选项，至于有啥含义，对本文并不重要。</p><p>这个epoll实例内部维护了两个重要结构，分别是<code>需要监听的文件描述符树</code>和<code>就绪的文件描述符</code>（这两个结构下文会讲），对于就绪的文件描述符，他们会被返回给用户进程进行处理，从这个角度来说，<strong>epoll避免了每次select/poll之后用户进程需要扫描所有文件描述符的问题</strong>。</p><h4 id="_5-1-2-epoll注册事件" tabindex="-1"><a class="header-anchor" href="#_5-1-2-epoll注册事件" aria-hidden="true">#</a> 5.1.2. epoll注册事件</h4><p>创建完epoll实例之后，我们可以使用<code>epoll_ctl</code>（<code>ctl</code>就是control的缩写）函数，向epoll实例中添加、修改或删除我们感兴趣的某个文件描述符的某些事件。</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">//  返回值: 若成功返回0；若返回-1表示出错</span>
<span class="token keyword">int</span> <span class="token function">epoll_ctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span> <span class="token keyword">int</span> op<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token operator">*</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>  
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>第一个参数<code>epfd</code>就是刚才调用<code>epoll_create</code>创建的epoll实例的描述符，也就是epoll的句柄。</p><p>第二个参数<code>op</code>表示要进行什么控制操作，有3个选项</p><ul><li><code>EPOLL_CTL_ADD</code>： 向 epoll 实例<strong>注册</strong>文件描述符对应的事件；</li><li><code>EPOLL_CTL_DEL</code>：向 epoll 实例<strong>删除</strong>文件描述符对应的事件；</li><li><code>EPOLL_CTL_MOD</code>： <strong>修改</strong>文件描述符对应的事件。</li></ul><p>第三个参数<code>fd</code>很简单，就是被操作的文件描述符。</p><p>第四个参数就是注册的事件类型，我们先看一下<code>epoll_event</code>的定义：</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token punctuation">{</span>
     <span class="token class-name">uint32_t</span>     events<span class="token punctuation">;</span>      <span class="token comment">/* 向epoll订阅的事件 */</span>
     <span class="token class-name">epoll_data_t</span> data<span class="token punctuation">;</span>        <span class="token comment">/* 用户数据 */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">union</span> epoll_data <span class="token punctuation">{</span>
     <span class="token keyword">void</span>        <span class="token operator">*</span>ptr<span class="token punctuation">;</span>
     <span class="token keyword">int</span>          fd<span class="token punctuation">;</span>
     <span class="token class-name">uint32_t</span>     u32<span class="token punctuation">;</span>
     <span class="token class-name">uint64_t</span>     u64<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token class-name">epoll_data_t</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>events</code>这个字段和<code>poll</code>的<code>events</code>参数一样，都是通过二进制掩码设置事件类型，epoll的事件类型在<code>/usr/include/sys/epoll.h</code>中有定义，更详细的可以使用<code>man epoll_ctl</code>看一下文档说明，其中内容很多，知道有这么回事儿就行了，但是注意一下<code>EPOLLET</code>这个事件，我特意加了一下注释，下文会讲到。</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">enum</span> <span class="token class-name">EPOLL_EVENTS</span> <span class="token punctuation">{</span>
      EPOLLIN <span class="token operator">=</span> <span class="token number">0x001</span><span class="token punctuation">,</span>
  		<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EPOLLIN</span> <span class="token expression">EPOLLIN</span></span>
      EPOLLPRI <span class="token operator">=</span> <span class="token number">0x002</span><span class="token punctuation">,</span>
  		<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EPOLLPRI</span> <span class="token expression">EPOLLPRI</span></span>
      EPOLLOUT <span class="token operator">=</span> <span class="token number">0x004</span><span class="token punctuation">,</span>
  		<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EPOLLOUT</span> <span class="token expression">EPOLLOUT</span></span>
      EPOLLRDNORM <span class="token operator">=</span> <span class="token number">0x040</span><span class="token punctuation">,</span>
  		<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EPOLLRDNORM</span> <span class="token expression">EPOLLRDNORM</span></span>
      EPOLLRDBAND <span class="token operator">=</span> <span class="token number">0x080</span><span class="token punctuation">,</span>
  		<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EPOLLRDBAND</span> <span class="token expression">EPOLLRDBAND</span></span>
      EPOLLWRNORM <span class="token operator">=</span> <span class="token number">0x100</span><span class="token punctuation">,</span>
  		<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EPOLLWRNORM</span> <span class="token expression">EPOLLWRNORM</span></span>
      EPOLLWRBAND <span class="token operator">=</span> <span class="token number">0x200</span><span class="token punctuation">,</span>
  		<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EPOLLWRBAND</span> <span class="token expression">EPOLLWRBAND</span></span>
      EPOLLMSG <span class="token operator">=</span> <span class="token number">0x400</span><span class="token punctuation">,</span>
  		<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EPOLLMSG</span> <span class="token expression">EPOLLMSG</span></span>
      EPOLLERR <span class="token operator">=</span> <span class="token number">0x008</span><span class="token punctuation">,</span>
  		<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EPOLLERR</span> <span class="token expression">EPOLLERR</span></span>
      EPOLLHUP <span class="token operator">=</span> <span class="token number">0x010</span><span class="token punctuation">,</span>
  		<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EPOLLHUP</span> <span class="token expression">EPOLLHUP</span></span>
      EPOLLRDHUP <span class="token operator">=</span> <span class="token number">0x2000</span><span class="token punctuation">,</span>
  		<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EPOLLRDHUP</span> <span class="token expression">EPOLLRDHUP</span></span>
      EPOLLWAKEUP <span class="token operator">=</span> <span class="token number">1u</span> <span class="token operator">&lt;&lt;</span> <span class="token number">29</span><span class="token punctuation">,</span>
  		<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EPOLLWAKEUP</span> <span class="token expression">EPOLLWAKEUP</span></span>
      EPOLLONESHOT <span class="token operator">=</span> <span class="token number">1u</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">,</span>
  		<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EPOLLONESHOT</span> <span class="token expression">EPOLLONESHOT</span></span>
  		<span class="token comment">// 设置为 edge-triggered，默认为 level-triggered</span>
      EPOLLET <span class="token operator">=</span> <span class="token number">1u</span> <span class="token operator">&lt;&lt;</span> <span class="token number">31</span>
  		<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EPOLLET</span> <span class="token expression">EPOLLET</span></span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>data</code>字段比较有意思，我们可以在<code>data</code>中设置我们需要的数据，具体是什么意思现在说起来还有点麻烦，稍安勿躁，我们接着看最后一个函数。</p><h4 id="_5-1-3-epoll-wait" tabindex="-1"><a class="header-anchor" href="#_5-1-3-epoll-wait" aria-hidden="true">#</a> 5.1.3. epoll_wait</h4><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">// 返回值: 成功返回的是一个大于0的数，表示事件的个数；0表示超时；出错返回-1.</span>
<span class="token keyword">int</span> <span class="token function">epoll_wait</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token operator">*</span>events<span class="token punctuation">,</span> <span class="token keyword">int</span> maxevents<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这个是不是就感觉很熟悉了啊。<code>epoll_wait</code>的用法和<code>select/poll</code>很类似，用户进程被阻塞。不同的是，<code>epoll</code>会直接告诉用户进程哪些描述符已经就绪了。</p><p>第一个参数是<code>epoll</code>实例的描述符。</p><p>第二个参数是返回给用户空间的需要处理的I/O事件，是一个<code>epoll_event</code>类型的数组，数组的长度就是<code>epoll_wait</code>函数的返回值，再看一眼这个结构吧。</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token punctuation">{</span>
     <span class="token class-name">uint32_t</span>     events<span class="token punctuation">;</span>      <span class="token comment">/* 向epoll订阅的事件 */</span>
     <span class="token class-name">epoll_data_t</span> data<span class="token punctuation">;</span>        <span class="token comment">/* 用户数据 */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">union</span> epoll_data <span class="token punctuation">{</span>
     <span class="token keyword">void</span>        <span class="token operator">*</span>ptr<span class="token punctuation">;</span>
     <span class="token keyword">int</span>          fd<span class="token punctuation">;</span>
     <span class="token class-name">uint32_t</span>     u32<span class="token punctuation">;</span>
     <span class="token class-name">uint64_t</span>     u64<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token class-name">epoll_data_t</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>events</code> 表示具体的事件类型，至于这个<code>data</code>就是在<code>epoll_ctl</code>中设置的<code>data</code>，这样用户进程收到这个<code>epoll_event</code>，根据之前设置的<code>data</code>就能获取到相关信息，然后进行逻辑处理了。</p><p>第三个参数是一个大于 <code>0</code> 的整数，表示 <code>epoll_wait</code> 可以返回的最大事件值。</p><p>第四个参数是 <code>epoll_wait</code> 阻塞调用的超时值，如果设置为 <code>-1</code>，表示不超时；如果设置为 <code>0</code> 则立即返回，即使没有任何 I/O 事件发生。</p><h3 id="_5-2-edge-triggered-和-level-triggered" tabindex="-1"><a class="header-anchor" href="#_5-2-edge-triggered-和-level-triggered" aria-hidden="true">#</a> 5.2. edge-triggered 和 level-triggered</h3><p><code>epoll</code>还提供了一个利器——边缘触发（edge-triggered），也就是上文我没解释的<code>EPOLLET</code> 参数。</p><p>啥意思呢？我举个例子。如果有个socket有100个字节的数据可读，边缘触发（edge-triggered）和条件触发（level-triggered）都会产生<strong>读就绪</strong>事件。</p><p>但是如果用户进程只读取了50个字节，边缘触发就会陷入等待，数据不会丢失，但是你爱读不读，反正老子已经通知过你了；而条件触发会因为你还没有读完，兢兢业业地不停产生<strong>读就绪</strong>事件催你去读。</p><p>边缘触发只会产生一次事件提醒，效率和性能要高于条件触发，这是epoll的一个大杀器。</p><h3 id="_5-3-epoll进阶" tabindex="-1"><a class="header-anchor" href="#_5-3-epoll进阶" aria-hidden="true">#</a> 5.3. epoll进阶</h3><h4 id="_5-3-1-file-operations与poll" tabindex="-1"><a class="header-anchor" href="#_5-3-1-file-operations与poll" aria-hidden="true">#</a> 5.3.1. file_operations与poll</h4><p>进阶之前问个小问题，Linux下所有文件都可以使用<code>select/poll/epoll</code>来监听文件变化吗？</p><p><strong>答案是不行！</strong></p><p>只有底层驱动实现了 <code>file_operations</code> 中 <code>poll</code> 函数的文件类型才可以被 <code>epoll</code> 监视！</p><blockquote><p>注意，这里的<code>file_operations</code>中定义的<code>poll</code>和上文讲到的<code>poll()</code>是两码事儿，只是恰好名字一样罢了。</p></blockquote><p><strong>socket 类型的文件驱动实现了 poll 函数，具体实现是sock_poll()，因此才可以被 epoll 监视</strong>。</p><p>下面我摘录了 <code>file_operations</code> 中我们常见的函数定义给大家看一下。</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">// file: include/linux/fs.h</span>
<span class="token keyword">struct</span> <span class="token class-name">file_operations</span> <span class="token punctuation">{</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token class-name">ssize_t</span> <span class="token punctuation">(</span><span class="token operator">*</span>read<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">char</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token class-name">size_t</span><span class="token punctuation">,</span> <span class="token class-name">loff_t</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token class-name">ssize_t</span> <span class="token punctuation">(</span><span class="token operator">*</span>write<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token class-name">size_t</span><span class="token punctuation">,</span> <span class="token class-name">loff_t</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>poll<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">poll_table_struct</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>open<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>flush<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token class-name">fl_owner_t</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>release<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>有点懵对吧，继续看。</p><p>Linux对文件的操作做了高度的抽象，每个开发者都可以开发自己的文件系统，Linux并不知道其中的具体文件应该怎样<code>open</code>、<code>read/write</code>或者<code>release</code>，所以Linux定义了<code>file_operations</code>这个“接口”，设备类型需要自己实现<code>struct file_operations</code>结构中定义的函数的细节。有点类似于Java中的接口和具体实现类的关系。</p><p><code>poll</code>函数的作用我们下文再说。</p><h4 id="_5-3-2-epoll内核对象的创建" tabindex="-1"><a class="header-anchor" href="#_5-3-2-epoll内核对象的创建" aria-hidden="true">#</a> 5.3.2. epoll内核对象的创建</h4><p><code>epoll_create()</code>的主要作用是创建一个<code>struct eventpoll</code>内核对象，后续epoll的操作大部分都是对这个数据结构的操作。</p><p><img src="https://qiniu.chanmufeng.com/2023-01-29-050640.png" alt="eventpoll对象" loading="lazy"></p><ul><li><code>wq</code>：等待队列。双向链表，软中断就绪的时候会通过<code>wq</code>找到阻塞在epoll对象上的进程；</li><li><code>rdllist</code>：就绪的描述符链表。双向链表，当描述符就绪时，内核会将就绪的描述符放到<code>rdllist</code>，这样用户进程就可以通过该链表直接找到就绪的描述符；</li><li><code>rbr</code>：<strong>R</strong>ed <strong>B</strong>lack <strong>R</strong>oot。指向红黑树根节点，里边的每个节点表示的就是epoll监听的文件描述符。</li></ul><p>然后，内核将<code>eventpoll</code>加入到当前进程已打开的文件列表中。啥？<code>eventpoll</code>也是一个文件？别急，我们看看<code>epoll_create1</code>的源码。</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">//file: /fs/eventpoll.c</span>
<span class="token function">SYSCALL_DEFINE1</span><span class="token punctuation">(</span>epoll_create1<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> flags<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">int</span> error<span class="token punctuation">,</span> fd<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">eventpoll</span> <span class="token operator">*</span>ep <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">;</span>
	
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  
  <span class="token comment">// 1. 为struct eventpoll分配内存并初始化</span>
  <span class="token comment">// 		初始化操作主要包括初始化等待队列wq、rdllist、rbr等</span>
	error <span class="token operator">=</span> <span class="token function">ep_alloc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ep<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  
  <span class="token comment">// 2. 获取一个可用的描述符号fd，此时fd还未与具体的file绑定</span>
	fd <span class="token operator">=</span> <span class="token function">get_unused_fd_flags</span><span class="token punctuation">(</span>O_RDWR <span class="token operator">|</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> O_CLOEXEC<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    
  <span class="token comment">// 3. 创建一个名为&quot;[eventpoll]&quot;的匿名文件file</span>
  <span class="token comment">//		并将eventpoll对象赋值到匿名文件file的private_data字段进行关联</span>
	file <span class="token operator">=</span> <span class="token function">anon_inode_getfile</span><span class="token punctuation">(</span><span class="token string">&quot;[eventpoll]&quot;</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>eventpoll_fops<span class="token punctuation">,</span> ep<span class="token punctuation">,</span>
				 O_RDWR <span class="token operator">|</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> O_CLOEXEC<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
  <span class="token comment">// 4. 将eventpoll对象的file指针指向刚创建的匿名文件file</span>
	ep<span class="token operator">-&gt;</span>file <span class="token operator">=</span> file<span class="token punctuation">;</span>
  
  <span class="token comment">// 5. 将fd和匿名文件file进行绑定</span>
	<span class="token function">fd_install</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> file<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> fd<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>好好看一下代码中的注释（一定要看！），代码执行完毕的结果就如下图这般。</p><p><img src="https://qiniu.chanmufeng.com/2023-01-29-054916.png" alt="进程与epoll" loading="lazy"></p><p>调用<code>epoll_create1</code>后得到的文件描述符本质上是匿名文件<code>[eventpoll]</code>的描述符，该匿名文件中的<code>private_data</code>字段才指向了真正的<code>eventpoll</code>对象。</p><p>Linux中的一切皆文件并非虚言。这样一来，<code>eventpoll文件</code>也可以被epoll本身监测，也就是说epoll实例可以监听其他的epoll实例，这一点很重要。</p><p>至此，<code>epoll_create1</code>调用结束。是不是很简单呐～</p><h4 id="_5-3-3-添加socket到epoll" tabindex="-1"><a class="header-anchor" href="#_5-3-3-添加socket到epoll" aria-hidden="true">#</a> 5.3.3. 添加socket到epoll</h4><p>现在我们考虑使用<code>EPOLL_CTL_ADD</code>向epoll实例中添加fd的情况。</p><blockquote><p>接下来会涉及到较多的源码，别恐惧，都很简单</p></blockquote><p>这时候就要用到上文的<code>rbr</code>红黑树了， <code>epoll_ctl</code>对fd的增删改操查作实际上就是对这棵红黑树进行操作，树的节点结构<code>epitem</code>如下所示：</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">// file: /fs/eventpoll.c</span>
<span class="token keyword">struct</span> <span class="token class-name">epitem</span> <span class="token punctuation">{</span>
	<span class="token comment">/* 红黑树的节点 */</span>
	<span class="token keyword">struct</span> <span class="token class-name">rb_node</span> rbn<span class="token punctuation">;</span>

	<span class="token comment">/* 用于将当前epitem连接到eventpoll中rdllist中的工具 */</span>
	<span class="token keyword">struct</span> <span class="token class-name">list_head</span> rdllink<span class="token punctuation">;</span>

	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

	<span class="token comment">/* 该结构保存了我们想让epoll监听的fd以及该fd对应的file */</span>
	<span class="token keyword">struct</span> <span class="token class-name">epoll_filefd</span> ffd<span class="token punctuation">;</span>


	<span class="token comment">/* 当前epitem属于哪个eventpoll */</span>
	<span class="token keyword">struct</span> <span class="token class-name">eventpoll</span> <span class="token operator">*</span>ep<span class="token punctuation">;</span>

<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://qiniu.chanmufeng.com/2023-01-29-061214.png" alt="红黑树与epitem" loading="lazy"></p><p>接着我们看一下<code>epoll_ctl</code>的源码。</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">// file: /fs/eventpoll.c</span>
<span class="token function">SYSCALL_DEFINE4</span><span class="token punctuation">(</span>epoll_ctl<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> epfd<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> op<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> fd<span class="token punctuation">,</span>
		<span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> event<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token operator">*</span>tfile<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">eventpoll</span> <span class="token operator">*</span>ep<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">epitem</span> <span class="token operator">*</span>epi<span class="token punctuation">;</span>

	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

	<span class="token comment">/* 根据epfd找到eventpoll对应的匿名文件 */</span>
	file <span class="token operator">=</span> <span class="token function">fget</span><span class="token punctuation">(</span>epfd<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">/* fd是我们感兴趣的socket描述符，根据它找到对应的文件 */</span>
	tfile <span class="token operator">=</span> <span class="token function">fget</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
  <span class="token comment">/* 根据file的private_data字段找到eventpoll实例 */</span>
	ep <span class="token operator">=</span> file<span class="token operator">-&gt;</span>private_data<span class="token punctuation">;</span>

	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token comment">/* 在红黑树中查找一下，看看是不是已经存在了
			如果存在了，那就报错；否则，执行ep_insert */</span>
  epi <span class="token operator">=</span> <span class="token function">ep_find</span><span class="token punctuation">(</span>ep<span class="token punctuation">,</span> tfile<span class="token punctuation">,</span> fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
  
	<span class="token keyword">switch</span> <span class="token punctuation">(</span>op<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">case</span> EPOLL_CTL_ADD<span class="token operator">:</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>epi<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			epds<span class="token punctuation">.</span>events <span class="token operator">|=</span> POLLERR <span class="token operator">|</span> POLLHUP<span class="token punctuation">;</span>
			error <span class="token operator">=</span> <span class="token function">ep_insert</span><span class="token punctuation">(</span>ep<span class="token punctuation">,</span> <span class="token operator">&amp;</span>epds<span class="token punctuation">,</span> tfile<span class="token punctuation">,</span> fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span>
			error <span class="token operator">=</span> <span class="token operator">-</span>EEXIST<span class="token punctuation">;</span>
		<span class="token function">clear_tfile_check_list</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">break</span><span class="token punctuation">;</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token punctuation">}</span>
  
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>epoll_ctl</code>中，首先根据传入的<code>epfd</code>以及<code>fd</code>找到相关的内核对象，然后在红黑树中判断这个<code>epitem</code>是不是已经存在，存在的话就报错，否则继续执行<code>ep_insert</code>函数。</p><p><code>ep_insert</code>故名思义就是将<code>epitem</code>结构插入到红黑树当中，但是并非单纯插入那么简单，其中涉及到一些细节。</p><h5 id="_5-3-3-1-ep-insert" tabindex="-1"><a class="header-anchor" href="#_5-3-3-1-ep-insert" aria-hidden="true">#</a> 5.3.3.1. ep_insert</h5><p>很多关键操作都是在<code>ep_insert</code>函数中完成的，看一下源码。</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">// file: /fs/eventpoll.c</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">ep_insert</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">eventpoll</span> <span class="token operator">*</span>ep<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token operator">*</span>event<span class="token punctuation">,</span>
		     <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>tfile<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">int</span> error<span class="token punctuation">,</span> revents<span class="token punctuation">,</span> pwake <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">;</span>
	<span class="token keyword">long</span> user_watches<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">epitem</span> <span class="token operator">*</span>epi<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">ep_pqueue</span> epq<span class="token punctuation">;</span>

	<span class="token comment">// 1. 分配epitem内存空间</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>epi <span class="token operator">=</span> <span class="token function">kmem_cache_alloc</span><span class="token punctuation">(</span>epi_cache<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token operator">-</span>ENOMEM<span class="token punctuation">;</span>
	
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    
	<span class="token comment">// 2. 将epitem进行初始化</span>
	<span class="token function">INIT_LIST_HEAD</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>epi<span class="token operator">-&gt;</span>rdllink<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">INIT_LIST_HEAD</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>epi<span class="token operator">-&gt;</span>fllink<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">INIT_LIST_HEAD</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>epi<span class="token operator">-&gt;</span>pwqlist<span class="token punctuation">)</span><span class="token punctuation">;</span>
	epi<span class="token operator">-&gt;</span>ep <span class="token operator">=</span> ep<span class="token punctuation">;</span>
	<span class="token function">ep_set_ffd</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>epi<span class="token operator">-&gt;</span>ffd<span class="token punctuation">,</span> tfile<span class="token punctuation">,</span> fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
	epi<span class="token operator">-&gt;</span>event <span class="token operator">=</span> <span class="token operator">*</span>event<span class="token punctuation">;</span>
	epi<span class="token operator">-&gt;</span>nwait <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	epi<span class="token operator">-&gt;</span>next <span class="token operator">=</span> EP_UNACTIVE_PTR<span class="token punctuation">;</span>
	
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

	<span class="token comment">/* 3. 初始化 poll table，设置回调函数为ep_ptable_queue_proc */</span>
	epq<span class="token punctuation">.</span>epi <span class="token operator">=</span> epi<span class="token punctuation">;</span>
	<span class="token function">init_poll_funcptr</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>epq<span class="token punctuation">.</span>pt<span class="token punctuation">,</span> ep_ptable_queue_proc<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">/*
	 * 4. 调用ep_ptable_queue_proc函数，
	 * 		设置socket等待队列的回调函数为ep_poll_callback
	 */</span>
	revents <span class="token operator">=</span> <span class="token function">ep_item_poll</span><span class="token punctuation">(</span>epi<span class="token punctuation">,</span> <span class="token operator">&amp;</span>epq<span class="token punctuation">.</span>pt<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	
	<span class="token comment">/* 5. epitem插入eventpoll的红黑树 */</span>
	<span class="token function">ep_rbtree_insert</span><span class="token punctuation">(</span>ep<span class="token punctuation">,</span> epi<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="_5-3-3-2-分配与初始化epitem" tabindex="-1"><a class="header-anchor" href="#_5-3-3-2-分配与初始化epitem" aria-hidden="true">#</a> 5.3.3.2. 分配与初始化epitem</h5><p>虽然源码行数不少，但是这一步非常简单，就是将<code>epitem</code>中的数据准备好，到插入的时候直接拿来用就行了。用一张图来说明这一步的重点问题。</p><p><img src="https://qiniu.chanmufeng.com/2023-01-29-065904.png" alt="epitem初始化" loading="lazy"></p><p><code>epitem</code>已经准备好了，也就是监听的socket对象已经有了，就差插入到红黑树了，但是在插入之前需要解决个问题，当监听的对象就绪了之后内核该怎么办？</p><p>那就是设置回调函数！</p><p>这个回调函数是通过函数 <code>ep_ptable_queue_proc</code> 来进行设置的。回调函数是干什么的呢？就是当对应的文件描述符上有事件发生，就会调用这个函数，比如socket缓冲区有数据了，内核就会回调这个函数。这个函数就是 <code>ep_poll_callback</code>。</p><h5 id="_5-3-3-3-设置回调函数" tabindex="-1"><a class="header-anchor" href="#_5-3-3-3-设置回调函数" aria-hidden="true">#</a> 5.3.3.3. 设置回调函数</h5><p>这一小节就是通过源码讲解如何设置<code>ep_poll_callback</code>回调函数的。</p><blockquote><p>没有耐心的话可以暂时跳过这一小节，但是强烈建议整体看完之后回看这部分内容。</p></blockquote><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">// file: /include/linux/poll.h</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">init_poll_funcptr</span><span class="token punctuation">(</span>poll_table <span class="token operator">*</span>pt<span class="token punctuation">,</span> poll_queue_proc qproc<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	pt<span class="token operator">-&gt;</span>_qproc <span class="token operator">=</span> qproc<span class="token punctuation">;</span>
	pt<span class="token operator">-&gt;</span>_key   <span class="token operator">=</span> <span class="token operator">~</span><span class="token number">0UL</span><span class="token punctuation">;</span> <span class="token comment">/* all events enabled */</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>init_poll_funcptr</code>函数将<code>poll_table</code>结构的<code>_qproc</code>函数指针设置为<code>qproc</code>参数，也就是在<code>ep_insert</code>中看到的<code>ep_ptable_queue_proc</code>函数。</p><p>接下来轮到<code>ep_item_poll</code>了，扒开它看看。</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">// file: /fs/eventpoll.c</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token function">ep_item_poll</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">epitem</span> <span class="token operator">*</span>epi<span class="token punctuation">,</span> poll_table <span class="token operator">*</span>pt<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  pt<span class="token operator">-&gt;</span>_key <span class="token operator">=</span> epi<span class="token operator">-&gt;</span>event<span class="token punctuation">.</span>events<span class="token punctuation">;</span>
	
  <span class="token comment">// 这行是重点</span>
	<span class="token keyword">return</span> epi<span class="token operator">-&gt;</span>ffd<span class="token punctuation">.</span>file<span class="token operator">-&gt;</span>f_op<span class="token operator">-&gt;</span><span class="token function">poll</span><span class="token punctuation">(</span>epi<span class="token operator">-&gt;</span>ffd<span class="token punctuation">.</span>file<span class="token punctuation">,</span> pt<span class="token punctuation">)</span> <span class="token operator">&amp;</span> epi<span class="token operator">-&gt;</span>event<span class="token punctuation">.</span>events<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>重点来了，通过上文我们知道了，<code>ffd.file</code>指的是socket代表的文件，也就是调用了socket文件自己实现的<code>poll</code>方法，也就是上文提到过的<code>sock_poll()</code>。</p><p>然后经过下面层层函数调用，最终来到了<code>poll_wait</code>函数。</p><p><img src="https://qiniu.chanmufeng.com/2023-01-30-064134.png" alt="" loading="lazy"></p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">// file: /include/linux/poll.h</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">poll_wait</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span> filp<span class="token punctuation">,</span> <span class="token class-name">wait_queue_head_t</span> <span class="token operator">*</span> wait_address<span class="token punctuation">,</span> poll_table <span class="token operator">*</span>p<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">&amp;&amp;</span> p<span class="token operator">-&gt;</span>_qproc <span class="token operator">&amp;&amp;</span> wait_address<span class="token punctuation">)</span>
		p<span class="token operator">-&gt;</span><span class="token function">_qproc</span><span class="token punctuation">(</span>filp<span class="token punctuation">,</span> wait_address<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>你看，<code>poll_wait</code>又调用了<code>poll_table</code>的<code>_qproc</code>函数，我们刚刚在<code>init_poll_funcptr</code>中将其设置为了<code>ep_ptable_queue_proc</code>，于是，代码来到了<code>ep_ptable_queue_proc</code>。</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">// file: /fs/eventpoll.c</span>
<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">ep_ptable_queue_proc</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token class-name">wait_queue_head_t</span> <span class="token operator">*</span>whead<span class="token punctuation">,</span>
				 poll_table <span class="token operator">*</span>pt<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    
	<span class="token keyword">if</span> <span class="token punctuation">(</span>epi<span class="token operator">-&gt;</span>nwait <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>pwq <span class="token operator">=</span> <span class="token function">kmem_cache_alloc</span><span class="token punctuation">(</span>pwq_cache<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		
    <span class="token comment">// 设置最终的回调方法ep_poll_callback</span>
    <span class="token function">init_waitqueue_func_entry</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pwq<span class="token operator">-&gt;</span>wait<span class="token punctuation">,</span> ep_poll_callback<span class="token punctuation">)</span><span class="token punctuation">;</span>
		
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    
    <span class="token comment">// 将包含ep_poll_callback在内的信息放入socket的等待队列</span>
		<span class="token function">add_wait_queue</span><span class="token punctuation">(</span>whead<span class="token punctuation">,</span> <span class="token operator">&amp;</span>pwq<span class="token operator">-&gt;</span>wait<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token punctuation">}</span> 
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>ep_ptable_queue_proc</code>被我简化地只剩2个函数调用了，我们在3.4节中提到了socket自己维护了一个等待队列<code>sk_wq</code>，并且这个等待队列中的每一项保存了阻塞在当前socket上的进程描述符（明确知道该唤醒谁）以及回调函数（内核明确知道数据来了该怎么做）。</p><p>这一系列的操作就是设置回调函数为<code>ep_poll_callback</code>，并封装队列项数据结构，然后把这个结构放到socket的等待队列中。</p><p>还有一个小问题，不知道朋友们注意到了没有，我没提保存当前用户进程信息这回事儿。这也是epoll更加高效的一个原因，现在socket已经完全托管给epoll了，因此我们不能在一个socket准备就绪的时候就立刻去唤醒进程，唤醒的时机得交给epoll，这就是为什么<code>eventpoll</code>对象还有一个队列的原因，里边存放的就是阻塞在epoll上的进程。</p><p>再看一遍这个结构。</p><p><img src="https://qiniu.chanmufeng.com/2023-01-29-050640.png" alt="eventpoll对象" loading="lazy"></p><p>说完这些，你可能在想，交给epoll不也是让epoll唤醒嘛，有啥区别？还有<code>ep_poll_callback</code>这个回调具体怎么用也没解释。</p><p>别急，现在还不是解释的时候，继续往下。</p><h5 id="_5-3-3-4-插入红黑树" tabindex="-1"><a class="header-anchor" href="#_5-3-3-4-插入红黑树" aria-hidden="true">#</a> 5.3.3.4. 插入红黑树</h5><p>最后一步就是通过<code>ep_rbtree_insert(ep, epi)</code>把<code>epitem</code>插入到红黑树中。</p><p><img src="https://qiniu.chanmufeng.com/2023-01-30-133712.png" alt="插入到红黑树" loading="lazy"></p><p>至此，<code>epoll_ctl</code>的整个调用过程全部结束。</p><p>此过程中我没有解释关于红黑树的任何操作，我也建议大家把它当成一个黑盒，只需要知道epoll底层采用了红黑树对<code>epitem</code>进行增删改查即可，毕竟学习红黑树不是我们的重点。</p><p>至于为什么内核开发者选择了红黑树这个结构，自然就是为了高效地管理<code>epitem</code>，使得在插入、查找、删除等各个方面不会因为<code>epitem</code>数量的增加而产生性能的剧烈波动。</p><p>上面几个小节的所有工作，得到了如下这一张图。</p><p><img src="https://qiniu.chanmufeng.com/2023-01-30-134543.png" alt="" loading="lazy"></p><h4 id="_5-3-4-epoll-wait" tabindex="-1"><a class="header-anchor" href="#_5-3-4-epoll-wait" aria-hidden="true">#</a> 5.3.4. epoll_wait</h4><p>epoll本身是阻塞的，阻塞也正是在这一步中体现的。</p><p>大部分人听到阻塞这个词就觉得很低效，这种想法并不对。</p><p><code>epoll_wait</code>做的事情就是检查<code>eventpoll</code>对象中的就绪fd列表<code>rdllist</code>中是否有数据，如果有，就说明有socket已经准备好了，那就直接返回，用户进程对该列表中的fd进行处理。</p><p>如果列表为空，那就将当前进程加入到<code>eventpoll</code>的进程等待队列<code>wq</code>中，让出CPU，主动进入睡眠状态。</p><p>也就是说，只要有活儿（fd就绪），epoll会玩儿命一直干，绝对不阻塞。但是一旦没活儿了，阻塞就是一种正确的选择，要不然一直占用CPU也是一种极大的浪费。因此，epoll避免了很多不必要的进程上下文切换。</p><p>好了，现在来看<code>epoll_wait</code>的实现吧。</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">// file: /fs/eventpoll.c</span>
<span class="token function">SYSCALL_DEFINE4</span><span class="token punctuation">(</span>epoll_wait<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> epfd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> events<span class="token punctuation">,</span>
		<span class="token keyword">int</span><span class="token punctuation">,</span> maxevents<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> timeout<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	error <span class="token operator">=</span> <span class="token function">ep_poll</span><span class="token punctuation">(</span>ep<span class="token punctuation">,</span> events<span class="token punctuation">,</span> maxevents<span class="token punctuation">,</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">ep_poll</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">eventpoll</span> <span class="token operator">*</span>ep<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> __user <span class="token operator">*</span>events<span class="token punctuation">,</span>
		   <span class="token keyword">int</span> maxevents<span class="token punctuation">,</span> <span class="token keyword">long</span> timeout<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

fetch_events<span class="token operator">:</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	
  <span class="token comment">// 如果就绪队列上没有时间发生，进入下面的逻辑</span>
  <span class="token comment">// 否则，就返回</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">ep_events_available</span><span class="token punctuation">(</span>ep<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token comment">/*
		 * We don&#39;t have any available event to return to the caller.
		 * We need to sleep here, and we will be wake up by
		 * ep_poll_callback() when events will become available.
		 */</span>
    <span class="token comment">// 定义等待队列项，并将当前线程和其进行绑定，并设置回调函数</span>
		<span class="token function">init_waitqueue_entry</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>wait<span class="token punctuation">,</span> current<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 将等待队列项加入到wq等待队列中</span>
		<span class="token function">__add_wait_queue_exclusive</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ep<span class="token operator">-&gt;</span>wq<span class="token punctuation">,</span> <span class="token operator">&amp;</span>wait<span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token comment">/*
			 * We don&#39;t want to sleep if the ep_poll_callback() sends us
			 * a wakeup in between. That&#39;s why we set the task state
			 * to TASK_INTERRUPTIBLE before doing the checks.
			 */</span>
      <span class="token comment">// 让出CPU，进入睡眠状态</span>
			<span class="token function">set_current_state</span><span class="token punctuation">(</span>TASK_INTERRUPTIBLE<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">schedule_hrtimeout_range</span><span class="token punctuation">(</span>to<span class="token punctuation">,</span> slack<span class="token punctuation">,</span> HRTIMER_MODE_ABS<span class="token punctuation">)</span><span class="token punctuation">)</span>
				timed_out <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
			<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>源码中有部分英文注释我没有删除，读一下这些注释可能会对理解整个过程有帮助。</p><p><code>ep_poll</code>做了以下几件事：</p><ol><li>判断<code>eventpoll</code>的<code>rdllist</code>队列上有没有就绪fd，如果有，那就直接返回；否则执行下面的步骤；</li><li>定义<code>eventpoll</code>的<code>wq</code>等待队列项，将当前进程绑定至队列项，并且设置回调函数；</li><li>将等待队列项加入到<code>wq</code>队列；</li><li>当前进程让出CPU，进入睡眠状态，进程阻塞。</li></ol><p>每一步都比较好理解，我们重点来看一下第2步，也就是<code>init_waitqueue_entry</code>函数。</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">// file: /include/linux/wait.h</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">init_waitqueue_entry</span><span class="token punctuation">(</span><span class="token class-name">wait_queue_t</span> <span class="token operator">*</span>q<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	q<span class="token operator">-&gt;</span>flags <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	q<span class="token operator">-&gt;</span>private <span class="token operator">=</span> p<span class="token punctuation">;</span>
	q<span class="token operator">-&gt;</span>func <span class="token operator">=</span> default_wake_function<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>wait_queue_t</code>就是<code>wq</code>等待队列项的结构体类型，将其中的<code>private</code>字段设置成了当前进程的<code>task_struct</code>结构体指针。然后将<code>default_wake_function</code>作为回调函数，赋值给了<code>func</code>字段，至于这个回调函数干嘛用的，还是别急，下文会说的。</p><p>于是，这个图又完整了一些。</p><p><img src="https://qiniu.chanmufeng.com/2023-01-31-003751.png" alt="完整的epoll图示" loading="lazy"></p><h4 id="_5-3-5-来活儿了" tabindex="-1"><a class="header-anchor" href="#_5-3-5-来活儿了" aria-hidden="true">#</a> 5.3.5. 来活儿了</h4><p>收到数据之后，首先干苦力活的是网卡，网卡会将数据放到某块关联的内存当中，这个操作不需要CPU的参与。等到数据保存完了之后，网卡会向CPU发起一个<strong>硬中断</strong>，通知CPU数据来了。</p><p>这个时候CPU就要开始对中断进行处理了，但是CPU太忙了，它必须时时刻刻准备好接收各种设备的中断，比如鼠标、键盘等，而且还不能卡在一个中断上太长时间，要不然可以想像我们的计算机得“卡”成什么样子。</p><p>所以实际设计中硬中断只负责做一些简单的事情，然后接着触发<strong>软中断</strong>，比较耗时且复杂的工作就交给软中断处理程序去做了。</p><p>软中断以内核线程的方式运行，每个CPU都会对应一个软中断内核线程，名字叫做<code>ksoftirqd/CPU编号</code>，比如 <code>0</code> 号 CPU 对应的软中断内核线程的名字是 <code>ksoftirqd/0</code>，为了方便，我们直接叫做ksoftirqd好了。</p><p>从这个角度上来说，操作系统就是一个死循环，在循环中不断接收各种中断，处理不同逻辑。</p><p>内核线程经过各个函数调用，最终会调用到就绪的socket等待队列项中的回调函数<code>ep_poll_callback</code>，是时候看看这个函数了。</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">// file: /fs/eventpoll.c</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">ep_poll_callback</span><span class="token punctuation">(</span><span class="token class-name">wait_queue_t</span> <span class="token operator">*</span>wait<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> mode<span class="token punctuation">,</span> <span class="token keyword">int</span> sync<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token comment">// 获取等待队列项对应的epitem</span>
	<span class="token keyword">struct</span> <span class="token class-name">epitem</span> <span class="token operator">*</span>epi <span class="token operator">=</span> <span class="token function">ep_item_from_wait</span><span class="token punctuation">(</span>wait<span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token comment">// 获取epitem对应的eventpoll实例</span>
	<span class="token keyword">struct</span> <span class="token class-name">eventpoll</span> <span class="token operator">*</span>ep <span class="token operator">=</span> epi<span class="token operator">-&gt;</span>ep<span class="token punctuation">;</span>

	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

	<span class="token comment">/* 如果当前epitem指向的socket已经在就绪队列里了，那就直接退出
			否则，将epitem添加到eventpoll的就绪队列rdllist中
			If this file is already in the ready list we exit soon 
	*/</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">ep_is_linked</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>epi<span class="token operator">-&gt;</span>rdllink<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">list_add_tail</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>epi<span class="token operator">-&gt;</span>rdllink<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ep<span class="token operator">-&gt;</span>rdllist<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 查看eventpoll等待队列上是否有等待的进程</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">waitqueue_active</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ep<span class="token operator">-&gt;</span>wq<span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token function">wake_up_locked</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ep<span class="token operator">-&gt;</span>wq<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>ep_poll_callback</code>的逻辑非常简洁清晰。</p><p>先找到就绪socket对应的等待队列项中的<code>epitem</code>，继而找到对应的<code>eventpoll</code>实例，再接口着判断当前的<code>epitem</code>是不是已经在<code>rdllist</code>就绪队列里了，如果在，那就没啥好做的了，函数退出就行了；如果不在，那就把<code>epitem</code>加入到<code>rdllist</code>中。</p><p>最后看看<code>eventpoll</code>的等待队列上是不是有阻塞的进程，有的话就调用5.3.4节中设置的<code>default_wake_function</code>回调函数来唤醒这个进程。</p><p>epoll中重点介绍的两个回调函数，<code>ep_poll_callback</code>和<code>default_wake_function</code>就串起来了。前者调用了后者，后者唤醒了进程。<code>epoll_wait</code>的最终使命就是将<code>rdllist</code>中的就绪fd返回给用户进程。</p><p><img src="https://qiniu.chanmufeng.com/2023-01-31-024118.png" alt="唤醒用户进程" loading="lazy"></p><h3 id="_5-4-epoll总结" tabindex="-1"><a class="header-anchor" href="#_5-4-epoll总结" aria-hidden="true">#</a> 5.4. epoll总结</h3><p>我们来梳理一下epoll的整个过程。</p><ol><li><code>epoll_create</code>创建了<code>eventpoll</code>实例，并对其中的就绪队列<code>rdllist</code>、等待队列<code>wq</code>以及红黑树<code>rbr</code>进行了初始化；</li><li><code>epoll_ctl</code>将我们感兴趣的socket封装成<code>epitem</code>对象加入红黑树，除此之外，还封装了socket的<code>sk_wq</code>等待队列项，里边保存了socket就绪之后的函数回调，也就是<code>ep_poll_callback</code>；</li><li><code>epoll_wait</code>检查<code>eventpoll</code>的就绪队列是不是有就绪的socket，有的话直接返回；否则就封装一个<code>eventpoll</code>的等待队列项，里边保存了当前的用户进程信息以及另一个回调函数<code>default_wake_function</code>，然后把当前进程投入睡眠；</li><li>直到数据到达，内核线程找到就绪的socket，先调用<code>ep_poll_callback</code>，然后<code>ep_poll_callback</code>又调用<code>default_wake_function</code>，最终唤醒<code>eventpoll</code>等待队列中保存的进程，处理<code>rdllist</code>中的就绪fd；</li><li>epoll结束！</li></ol><p>等下，还没结束！在5.3.2节中还留了一个小坑，我说：<code>eventpoll文件</code>也可以被epoll本身监测，也就是说epoll实例可以监听其他的epoll实例，这一点很重要。</p><p>怎么个重要法，这就涉及到<code>eventpoll</code>实例中的另一个队列了，叫做<code>poll_wait</code>。</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">eventpoll</span> <span class="token punctuation">{</span>
	
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

	<span class="token class-name">wait_queue_head_t</span> wq<span class="token punctuation">;</span>

	<span class="token comment">/* 就是它！！！！！！！ */</span>
	<span class="token class-name">wait_queue_head_t</span> poll_wait<span class="token punctuation">;</span>

	<span class="token keyword">struct</span> <span class="token class-name">list_head</span> rdllist<span class="token punctuation">;</span>

	<span class="token keyword">struct</span> <span class="token class-name">rb_root</span> rbr<span class="token punctuation">;</span>

	<span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://qiniu.chanmufeng.com/2023-01-31-031620.png" alt="递归监听的情况" loading="lazy"></p><p>如上图所示</p><ul><li><code>epollfd1</code>监听了2个普通描述符<code>fd1</code>和<code>fd2</code></li><li><code>epollfd2</code>监听了<code>epollfd1</code>和2个普通描述符<code>fd3</code>、<code>fd4</code></li></ul><p>如果<code>fd1</code>或<code>fd2</code>有<strong>可读事件</strong>触发，那么就绪的fd的回调函数<code>ep_poll_callback</code>对将该fd放到<code>epollfd1</code>的<code>rdllist</code>就绪队列中。由于<code>epollfd1</code>本身也是个文件，它的可读事件此时也被触发，但是<code>ep_poll_callback</code>怎么知道该把<code>epollfd1</code>放到谁的<code>rdllist</code>中呢？</p><p><code>poll_wait</code>来喽～～</p><p>当epoll监听epoll类型的文件的时候，会把监听者放入被监听者的<code>poll_wait</code>队列中，上面的例子就是<code>epollfd1</code>的<code>poll_wait</code>队列保存了<code>epollfd2</code>，这样一来，<code>当epollfd1</code>有可读事件触发，就可以在<code>poll_wait</code>中找到<code>epollfd2</code>，调用<code>epollfd1</code>的<code>ep_poll_callback</code>将<code>epollfd1</code>放入<code>epollfd2</code>的<code>rdllist</code>中。</p><p>所以<code>poll_wait</code>队列就是用来处理这种递归监听的情况的。</p><hr><p>到此为止，多路复用彻底结束～～～</p></div><!----><footer class="page-meta"><!----><div class="meta-item update-time"><span class="label">上次编辑于: </span><span class="info">2023/1/31 05:32:08</span></div><div class="meta-item contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: Wtwan521">zhaoxiaolong</span><!--]--><!--]--></div></footer><nav class="page-nav"><a href="/posts/storage/Redis/BIO%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9EIO.html" class="nav-link prev" aria-label="BIO与非阻塞IO"><div class="hint"><span class="arrow left"></span>上一页</div><div class="link"><span class="icon iconfont icon-creative"></span>BIO与非阻塞IO</div></a><a href="/posts/storage/Redis/%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E4%B8%8E%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E.html" class="nav-link next" aria-label="同步异步与阻塞非阻塞"><div class="hint">下一页<span class="arrow right"></span></div><div class="link">同步异步与阻塞非阻塞<span class="icon iconfont icon-creative"></span></div></a></nav><div class="giscus-wrapper input-top" style="display:block;"><div style="text-align:center">Loading...</div></div><!----><!--]--></main><!--]--><footer class="footer-wrapper"><div class="footer"><a href='https://beian.miit.gov.cn/'>鲁ICP备20023913号</a></div><div class="copyright">Copyright © 2023 蝉沐风</div></footer><!--]--></div><!--]--><!----><!--]--></div>
    <script type="module" src="/assets/app.33c79bea.js" defer></script>
  </body>
</html>
